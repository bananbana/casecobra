"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@uploadthing+shared@6.7.3_@uploadthing+mime-types@0.2.9";
exports.ids = ["vendor-chunks/@uploadthing+shared@6.7.3_@uploadthing+mime-types@0.2.9"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@uploadthing+shared@6.7.3_@uploadthing+mime-types@0.2.9/node_modules/@uploadthing/shared/dist/index.js":
/*!***********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@uploadthing+shared@6.7.3_@uploadthing+mime-types@0.2.9/node_modules/@uploadthing/shared/dist/index.js ***!
  \***********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ACLSchema: () => (/* binding */ ACLSchema),\n/* harmony export */   ALLOWED_FILE_TYPES: () => (/* binding */ ALLOWED_FILE_TYPES),\n/* harmony export */   BadRequestError: () => (/* binding */ BadRequestError),\n/* harmony export */   ContentDispositionSchema: () => (/* binding */ ContentDispositionSchema),\n/* harmony export */   FILESIZE_UNITS: () => (/* binding */ FILESIZE_UNITS),\n/* harmony export */   FetchContext: () => (/* binding */ FetchContext),\n/* harmony export */   FetchError: () => (/* binding */ FetchError),\n/* harmony export */   INTERNAL_DO_NOT_USE__fatalClientError: () => (/* binding */ INTERNAL_DO_NOT_USE__fatalClientError),\n/* harmony export */   INTERNAL_doFormatting: () => (/* binding */ INTERNAL_doFormatting),\n/* harmony export */   InvalidFileSizeError: () => (/* binding */ InvalidFileSizeError),\n/* harmony export */   InvalidFileTypeError: () => (/* binding */ InvalidFileTypeError),\n/* harmony export */   InvalidRouteConfigError: () => (/* binding */ InvalidRouteConfigError),\n/* harmony export */   InvalidURLError: () => (/* binding */ InvalidURLError),\n/* harmony export */   RetryError: () => (/* binding */ RetryError),\n/* harmony export */   UnknownFileTypeError: () => (/* binding */ UnknownFileTypeError),\n/* harmony export */   UploadThingError: () => (/* binding */ UploadThingError),\n/* harmony export */   allowedContentTextLabelGenerator: () => (/* binding */ allowedContentTextLabelGenerator),\n/* harmony export */   asArray: () => (/* binding */ asArray),\n/* harmony export */   bytesToFileSize: () => (/* binding */ bytesToFileSize),\n/* harmony export */   capitalizeStart: () => (/* binding */ capitalizeStart),\n/* harmony export */   contentDisposition: () => (/* binding */ contentDisposition),\n/* harmony export */   contentFieldToContent: () => (/* binding */ contentFieldToContent),\n/* harmony export */   exponentialBackoff: () => (/* binding */ exponentialBackoff),\n/* harmony export */   fetchEff: () => (/* binding */ fetchEff),\n/* harmony export */   fetchEffJson: () => (/* binding */ fetchEffJson),\n/* harmony export */   fetchEffUnknown: () => (/* binding */ fetchEffUnknown),\n/* harmony export */   fileSizeToBytes: () => (/* binding */ fileSizeToBytes),\n/* harmony export */   fillInputRouteConfig: () => (/* binding */ fillInputRouteConfig),\n/* harmony export */   filterObjectValues: () => (/* binding */ filterObjectValues),\n/* harmony export */   generateClientDropzoneAccept: () => (/* binding */ generateClientDropzoneAccept),\n/* harmony export */   generateMimeTypes: () => (/* binding */ generateMimeTypes),\n/* harmony export */   generatePermittedFileTypes: () => (/* binding */ generatePermittedFileTypes),\n/* harmony export */   generateUploadThingURL: () => (/* binding */ generateUploadThingURL),\n/* harmony export */   getDefaultSizeForType: () => (/* binding */ getDefaultSizeForType),\n/* harmony export */   getErrorTypeFromStatusCode: () => (/* binding */ getErrorTypeFromStatusCode),\n/* harmony export */   getFilesFromClipboardEvent: () => (/* binding */ getFilesFromClipboardEvent),\n/* harmony export */   getFullApiUrl: () => (/* binding */ getFullApiUrl),\n/* harmony export */   getRequestUrl: () => (/* binding */ getRequestUrl),\n/* harmony export */   getStatusCodeFromError: () => (/* binding */ getStatusCodeFromError),\n/* harmony export */   getTypeFromFileName: () => (/* binding */ getTypeFromFileName),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   isRouteArray: () => (/* binding */ isRouteArray),\n/* harmony export */   objectKeys: () => (/* binding */ objectKeys),\n/* harmony export */   parseRequestJson: () => (/* binding */ parseRequestJson),\n/* harmony export */   resolveMaybeUrlArg: () => (/* binding */ resolveMaybeUrlArg),\n/* harmony export */   safeParseJSON: () => (/* binding */ safeParseJSON),\n/* harmony export */   semverLite: () => (/* binding */ semverLite),\n/* harmony export */   signPayload: () => (/* binding */ signPayload),\n/* harmony export */   styleFieldToClassName: () => (/* binding */ styleFieldToClassName),\n/* harmony export */   styleFieldToCssObject: () => (/* binding */ styleFieldToCssObject),\n/* harmony export */   verifySignature: () => (/* binding */ verifySignature)\n/* harmony export */ });\n/* harmony import */ var _effect_schema_Schema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @effect/schema/Schema */ \"(ssr)/./node_modules/.pnpm/@effect+schema@0.66.16_effect@3.1.3_fast-check@3.18.0/node_modules/@effect/schema/dist/esm/Schema.js\");\n/* harmony import */ var effect_Effect__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! effect/Effect */ \"(ssr)/./node_modules/.pnpm/effect@3.1.3/node_modules/effect/dist/esm/Effect.js\");\n/* harmony import */ var std_env__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! std-env */ \"(ssr)/./node_modules/.pnpm/std-env@3.7.0/node_modules/std-env/dist/index.mjs\");\n/* harmony import */ var _uploadthing_mime_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @uploadthing/mime-types */ \"(ssr)/./node_modules/.pnpm/@uploadthing+mime-types@0.2.9/node_modules/@uploadthing/mime-types/dist/index.js\");\n/* harmony import */ var effect_Data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! effect/Data */ \"(ssr)/./node_modules/.pnpm/effect@3.1.3/node_modules/effect/dist/esm/Data.js\");\n/* harmony import */ var effect_Context__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! effect/Context */ \"(ssr)/./node_modules/.pnpm/effect@3.1.3/node_modules/effect/dist/esm/Context.js\");\n/* harmony import */ var effect_Duration__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! effect/Duration */ \"(ssr)/./node_modules/.pnpm/effect@3.1.3/node_modules/effect/dist/esm/Duration.js\");\n/* harmony import */ var effect_Function__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! effect/Function */ \"(ssr)/./node_modules/.pnpm/effect@3.1.3/node_modules/effect/dist/esm/Function.js\");\n/* harmony import */ var effect_Schedule__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! effect/Schedule */ \"(ssr)/./node_modules/.pnpm/effect@3.1.3/node_modules/effect/dist/esm/Schedule.js\");\n\n\n\n\n\n\n\n\n\n\nconst ContentDispositionSchema = _effect_schema_Schema__WEBPACK_IMPORTED_MODULE_1__.Literal(\"inline\", \"attachment\");\nconst ACLSchema = _effect_schema_Schema__WEBPACK_IMPORTED_MODULE_1__.Literal(\"public-read\", \"private\");\n\nclass InvalidRouteConfigError extends (0,effect_Data__WEBPACK_IMPORTED_MODULE_2__.TaggedError)(\"InvalidRouteConfig\") {\n    constructor(type, field){\n        const reason = field ? `Expected route config to have a ${field} for key ${type} but none was found.` : `Encountered an invalid route config during backfilling. ${type} was not found.`;\n        super({\n            reason\n        });\n    }\n}\nclass UnknownFileTypeError extends (0,effect_Data__WEBPACK_IMPORTED_MODULE_2__.TaggedError)(\"UnknownFileType\") {\n    constructor(fileName){\n        const reason = `Could not determine type for ${fileName}`;\n        super({\n            reason\n        });\n    }\n}\nclass InvalidFileTypeError extends (0,effect_Data__WEBPACK_IMPORTED_MODULE_2__.TaggedError)(\"InvalidFileType\") {\n    constructor(fileType, fileName){\n        const reason = `File type ${fileType} not allowed for ${fileName}`;\n        super({\n            reason\n        });\n    }\n}\nclass InvalidFileSizeError extends (0,effect_Data__WEBPACK_IMPORTED_MODULE_2__.TaggedError)(\"InvalidFileSize\") {\n    constructor(fileSize){\n        const reason = `Invalid file size: ${fileSize}`;\n        super({\n            reason\n        });\n    }\n}\nclass InvalidURLError extends (0,effect_Data__WEBPACK_IMPORTED_MODULE_2__.TaggedError)(\"InvalidURL\") {\n    constructor(attemptedUrl){\n        super({\n            reason: `Failed to parse '${attemptedUrl}' as a URL.`\n        });\n    }\n}\nclass RetryError extends (0,effect_Data__WEBPACK_IMPORTED_MODULE_2__.TaggedError)(\"RetryError\") {\n}\n/**\n * @internal\n */ const getRequestUrl = (input)=>{\n    if (input instanceof Request) {\n        return input.url;\n    }\n    return input.toString();\n};\nclass FetchError extends (0,effect_Data__WEBPACK_IMPORTED_MODULE_2__.TaggedError)(\"FetchError\") {\n}\nclass BadRequestError extends (0,effect_Data__WEBPACK_IMPORTED_MODULE_2__.TaggedError)(\"BadRequestError\") {\n    getMessage() {\n        if (isObject(this.error)) {\n            if (typeof this.error.message === \"string\") return this.error.message;\n        }\n        return this.message;\n    }\n}\n\nfunction isRouteArray(routeConfig) {\n    return Array.isArray(routeConfig);\n}\nfunction getDefaultSizeForType(fileType) {\n    if (fileType === \"image\") return \"4MB\";\n    if (fileType === \"video\") return \"16MB\";\n    if (fileType === \"audio\") return \"8MB\";\n    if (fileType === \"blob\") return \"8MB\";\n    if (fileType === \"pdf\") return \"4MB\";\n    if (fileType === \"text\") return \"64KB\";\n    return \"4MB\";\n}\n/**\n * This function takes in the user's input and \"upscales\" it to a full config\n *\n * Example:\n * ```ts\n * [\"image\"] => { image: { maxFileSize: \"4MB\", limit: 1 } }\n * ```\n */ const fillInputRouteConfig = (routeConfig)=>{\n    // If array, apply defaults\n    if (isRouteArray(routeConfig)) {\n        return effect_Effect__WEBPACK_IMPORTED_MODULE_3__.succeed(routeConfig.reduce((acc, fileType)=>{\n            acc[fileType] = {\n                // Apply defaults\n                maxFileSize: getDefaultSizeForType(fileType),\n                maxFileCount: 1,\n                minFileCount: 1,\n                contentDisposition: \"inline\"\n            };\n            return acc;\n        }, {}));\n    }\n    // Backfill defaults onto config\n    const newConfig = {};\n    for (const key of objectKeys(routeConfig)){\n        const value = routeConfig[key];\n        if (!value) return effect_Effect__WEBPACK_IMPORTED_MODULE_3__.fail(new InvalidRouteConfigError(key));\n        const defaultValues = {\n            maxFileSize: getDefaultSizeForType(key),\n            maxFileCount: 1,\n            minFileCount: 1,\n            contentDisposition: \"inline\"\n        };\n        newConfig[key] = {\n            ...defaultValues,\n            ...value\n        };\n    }\n    return effect_Effect__WEBPACK_IMPORTED_MODULE_3__.succeed(newConfig);\n};\nconst getTypeFromFileName = (fileName, allowedTypes)=>{\n    const mimeType = (0,_uploadthing_mime_types__WEBPACK_IMPORTED_MODULE_0__.lookup)(fileName);\n    if (!mimeType) {\n        if (allowedTypes.includes(\"blob\")) return effect_Effect__WEBPACK_IMPORTED_MODULE_3__.succeed(\"blob\");\n        return effect_Effect__WEBPACK_IMPORTED_MODULE_3__.fail(new UnknownFileTypeError(fileName));\n    }\n    // If the user has specified a specific mime type, use that\n    if (allowedTypes.some((type)=>type.includes(\"/\"))) {\n        if (allowedTypes.includes(mimeType)) {\n            return effect_Effect__WEBPACK_IMPORTED_MODULE_3__.succeed(mimeType);\n        }\n    }\n    // Otherwise, we have a \"magic\" type eg. \"image\" or \"video\"\n    const type = mimeType.toLowerCase() === \"application/pdf\" ? \"pdf\" : mimeType.split(\"/\")[0];\n    if (!allowedTypes.includes(type)) {\n        // Blob is a catch-all for any file type not explicitly supported\n        if (allowedTypes.includes(\"blob\")) {\n            return effect_Effect__WEBPACK_IMPORTED_MODULE_3__.succeed(\"blob\");\n        } else {\n            return effect_Effect__WEBPACK_IMPORTED_MODULE_3__.fail(new InvalidFileTypeError(type, fileName));\n        }\n    }\n    return effect_Effect__WEBPACK_IMPORTED_MODULE_3__.succeed(type);\n};\nfunction generateUploadThingURL(path) {\n    let host = \"https://uploadthing.com\";\n    if (std_env__WEBPACK_IMPORTED_MODULE_4__.process.env.CUSTOM_INFRA_URL) {\n        host = std_env__WEBPACK_IMPORTED_MODULE_4__.process.env.CUSTOM_INFRA_URL;\n    }\n    return `${host}${path}`;\n}\nconst FILESIZE_UNITS = [\n    \"B\",\n    \"KB\",\n    \"MB\",\n    \"GB\"\n];\nconst fileSizeToBytes = (fileSize)=>{\n    const regex = new RegExp(`^(\\\\d+)(\\\\.\\\\d+)?\\\\s*(${FILESIZE_UNITS.join(\"|\")})$`, \"i\");\n    // make sure the string is in the format of 123KB\n    const match = fileSize.match(regex);\n    if (!match) {\n        return effect_Effect__WEBPACK_IMPORTED_MODULE_3__.fail(new InvalidFileSizeError(fileSize));\n    }\n    const sizeValue = parseFloat(match[1]);\n    const sizeUnit = match[3].toUpperCase();\n    const bytes = sizeValue * Math.pow(1024, FILESIZE_UNITS.indexOf(sizeUnit));\n    return effect_Effect__WEBPACK_IMPORTED_MODULE_3__.succeed(Math.floor(bytes));\n};\nconst bytesToFileSize = (bytes)=>{\n    if (bytes === 0 || bytes === -1) {\n        return \"0B\";\n    }\n    const i = Math.floor(Math.log(bytes) / Math.log(1000));\n    return `${(bytes / Math.pow(1000, i)).toFixed(2)}${FILESIZE_UNITS[i]}`;\n};\nasync function safeParseJSON(input) {\n    if (typeof input === \"string\") {\n        try {\n            return JSON.parse(input);\n        } catch (err) {\n            console.error(`Error parsing JSON, got '${input}'`);\n            return new Error(`Error parsing JSON, got '${input}'`);\n        }\n    }\n    const text = await input.text();\n    try {\n        return JSON.parse(text ?? \"null\");\n    } catch (err) {\n        console.error(`Error parsing JSON, got '${text}'`);\n        return new Error(`Error parsing JSON, got '${text}'`);\n    }\n}\n/** typesafe Object.keys */ function objectKeys(obj) {\n    return Object.keys(obj);\n}\n/** checks if obj is a valid, non-null object */ function isObject(obj) {\n    return typeof obj === \"object\" && obj !== null && !Array.isArray(obj);\n}\nfunction asArray(val) {\n    return Array.isArray(val) ? val : [\n        val\n    ];\n}\n/**\n * Filters an object's values based on a predicate\n * @example\n * filterObjectValues({ a: \"a\", b: null }, (v): v is string => v != null)\n * // ^? Record<string, string> { a: \"a\" }\n */ const filterObjectValues = (obj, predicate)=>{\n    return Object.fromEntries(Object.entries(obj).filter(([_, v])=>predicate(v)));\n};\n/** construct content-disposition header */ function contentDisposition(contentDisposition, fileName) {\n    return [\n        contentDisposition,\n        `filename=\"${encodeURI(fileName)}\"`,\n        `filename*=UTF-8''${encodeURI(fileName)}`\n    ].join(\"; \");\n}\nfunction semverLite(required, toCheck) {\n    // Pull out numbers from strings like `6.0.0`, `^6.4`, `~6.4.0`\n    const semverRegex = /(\\d+)\\.?(\\d+)?\\.?(\\d+)?/;\n    const requiredMatch = required.match(semverRegex);\n    if (!requiredMatch?.[0]) {\n        throw new Error(`Invalid semver requirement: ${required}`);\n    }\n    const toCheckMatch = toCheck.match(semverRegex);\n    if (!toCheckMatch?.[0]) {\n        throw new Error(`Invalid semver to check: ${toCheck}`);\n    }\n    const [_1, rMajor, rMinor, rPatch] = requiredMatch;\n    const [_2, cMajor, cMinor, cPatch] = toCheckMatch;\n    if (required.startsWith(\"^\")) {\n        // Major must be equal, minor must be greater or equal\n        if (rMajor !== cMajor) return false;\n        if (rMinor > cMinor) return false;\n        return true;\n    }\n    if (required.startsWith(\"~\")) {\n        // Major must be equal, minor must be equal\n        if (rMajor !== cMajor) return false;\n        if (rMinor !== cMinor) return false;\n        return true;\n    }\n    // Exact match\n    return rMajor === cMajor && rMinor === cMinor && rPatch === cPatch;\n}\nconst getFullApiUrl = (maybeUrl)=>effect_Effect__WEBPACK_IMPORTED_MODULE_3__.gen(function*() {\n        const base = (()=>{\n            if (typeof window !== \"undefined\") return window.location.origin;\n            if (std_env__WEBPACK_IMPORTED_MODULE_4__.process.env?.VERCEL_URL) return `https://${std_env__WEBPACK_IMPORTED_MODULE_4__.process.env.VERCEL_URL}`;\n            return \"http://localhost:3000\";\n        })();\n        const url = yield* effect_Effect__WEBPACK_IMPORTED_MODULE_3__[\"try\"]({\n            try: ()=>new URL(maybeUrl ?? \"/api/uploadthing\", base),\n            catch: ()=>new InvalidURLError(maybeUrl ?? \"/api/uploadthing\")\n        });\n        if (url.pathname === \"/\") {\n            url.pathname = \"/api/uploadthing\";\n        }\n        return url;\n    });\n/*\n * Returns a full URL to the dev's uploadthing endpoint\n * Can take either an origin, or a pathname, or a full URL\n * and will return the \"closest\" url matching the default\n * `<VERCEL_URL || localhost>/api/uploadthing`\n */ const resolveMaybeUrlArg = (maybeUrl)=>{\n    return maybeUrl instanceof URL ? maybeUrl : effect_Effect__WEBPACK_IMPORTED_MODULE_3__.runSync(getFullApiUrl(maybeUrl));\n};\n\nconst ALLOWED_FILE_TYPES = [\n    \"image\",\n    \"video\",\n    \"audio\",\n    \"pdf\",\n    \"text\",\n    \"blob\"\n];\n\nconst ERROR_CODES = {\n    // Generic\n    BAD_REQUEST: 400,\n    NOT_FOUND: 404,\n    FORBIDDEN: 403,\n    INTERNAL_SERVER_ERROR: 500,\n    INTERNAL_CLIENT_ERROR: 500,\n    // S3 specific\n    TOO_LARGE: 413,\n    TOO_SMALL: 400,\n    TOO_MANY_FILES: 400,\n    KEY_TOO_LONG: 400,\n    // UploadThing specific\n    URL_GENERATION_FAILED: 500,\n    UPLOAD_FAILED: 500,\n    MISSING_ENV: 500,\n    FILE_LIMIT_EXCEEDED: 500\n};\nfunction messageFromUnknown(cause, fallback) {\n    if (typeof cause === \"string\") {\n        return cause;\n    }\n    if (cause instanceof Error) {\n        return cause.message;\n    }\n    if (cause && typeof cause === \"object\" && \"message\" in cause && typeof cause.message === \"string\") {\n        return cause.message;\n    }\n    return fallback ?? \"An unknown error occurred\";\n}\nclass UploadThingError extends (0,effect_Data__WEBPACK_IMPORTED_MODULE_2__.TaggedError)(\"UploadThingError\") {\n    constructor(initOpts){\n        const opts = typeof initOpts === \"string\" ? {\n            code: \"INTERNAL_SERVER_ERROR\",\n            message: initOpts\n        } : initOpts;\n        const message = opts.message ?? messageFromUnknown(opts.cause, opts.code);\n        super({\n            message\n        });\n        this.code = opts.code;\n        this.data = opts.data;\n        if (opts.cause instanceof Error) {\n            this.cause = opts.cause;\n        } else if (isObject(opts.cause) && typeof opts.cause.status === \"number\" && typeof opts.cause.statusText === \"string\") {\n            this.cause = new Error(`Response ${opts.cause.status} ${opts.cause.statusText}`);\n        } else if (typeof opts.cause === \"string\") {\n            this.cause = new Error(opts.cause);\n        } else {\n            this.cause = opts.cause;\n        }\n    }\n    static toObject(error) {\n        return {\n            code: error.code,\n            message: error.message,\n            data: error.data\n        };\n    }\n    static serialize(error) {\n        return JSON.stringify(UploadThingError.toObject(error));\n    }\n}\nfunction getErrorTypeFromStatusCode(statusCode) {\n    for (const [code, status] of Object.entries(ERROR_CODES)){\n        if (status === statusCode) {\n            return code;\n        }\n    }\n    return \"INTERNAL_SERVER_ERROR\";\n}\nfunction getStatusCodeFromError(error) {\n    return ERROR_CODES[error.code] ?? 500;\n}\nconst INTERNAL_DO_NOT_USE__fatalClientError = (e)=>new UploadThingError({\n        code: \"INTERNAL_CLIENT_ERROR\",\n        message: \"Something went wrong. Please report this to UploadThing.\",\n        cause: e\n    });\n\nclass FetchContext extends effect_Context__WEBPACK_IMPORTED_MODULE_5__.Tag(\"uploadthing/FetchContext\")() {\n}\n// Temporary Effect wrappers below.\n// TODO should be refactored with much love\n// TODO handle error properly\nconst fetchEff = (input, init)=>FetchContext.pipe(effect_Effect__WEBPACK_IMPORTED_MODULE_3__.andThen(({ fetch, baseHeaders })=>effect_Effect__WEBPACK_IMPORTED_MODULE_3__.tryPromise({\n            try: ()=>fetch(input, {\n                    ...init,\n                    headers: {\n                        ...filterObjectValues(baseHeaders, (v)=>v != null),\n                        ...init?.headers\n                    }\n                }),\n            catch: (error)=>new FetchError({\n                    error,\n                    input\n                })\n        })), effect_Effect__WEBPACK_IMPORTED_MODULE_3__.withSpan(\"fetch\", {\n        attributes: {\n            input: JSON.stringify(input)\n        }\n    }));\n// TODO: rename the other one to fetchEffJsonSchema and this to fetchEffJson\n// though generally I would avoid XandY kind utils in favor of composition\nconst fetchEffUnknown = (input, /** Schema to be used if the response returned a 2xx  */ init)=>{\n    const requestUrl = typeof input === \"string\" ? input : input instanceof URL ? input.toString() : input.url;\n    return fetchEff(input, init).pipe(effect_Effect__WEBPACK_IMPORTED_MODULE_3__.andThen((res)=>effect_Effect__WEBPACK_IMPORTED_MODULE_3__.tryPromise({\n            try: async ()=>{\n                const json = await res.json();\n                return {\n                    json,\n                    ok: res.ok,\n                    status: res.status\n                };\n            },\n            catch: (error)=>new FetchError({\n                    error,\n                    input\n                })\n        })), effect_Effect__WEBPACK_IMPORTED_MODULE_3__.filterOrFail(({ ok })=>ok, ({ json, status })=>new BadRequestError({\n            input,\n            status,\n            message: `Request to ${requestUrl} failed with status ${status}`,\n            error: json\n        })), effect_Effect__WEBPACK_IMPORTED_MODULE_3__.withSpan(\"fetchRawJson\", {\n        attributes: {\n            input: JSON.stringify(input)\n        }\n    }));\n};\nconst fetchEffJson = (input, /** Schema to be used if the response returned a 2xx  */ schema, init)=>{\n    return fetchEff(input, init).pipe(effect_Effect__WEBPACK_IMPORTED_MODULE_3__.andThen((res)=>effect_Effect__WEBPACK_IMPORTED_MODULE_3__.tryPromise({\n            try: async ()=>{\n                const json = await res.json();\n                return {\n                    ok: res.ok,\n                    json,\n                    status: res.status\n                };\n            },\n            catch: (error)=>new FetchError({\n                    error,\n                    input\n                })\n        })), effect_Effect__WEBPACK_IMPORTED_MODULE_3__.filterOrFail(({ ok })=>ok, ({ json, status })=>new BadRequestError({\n            input,\n            status,\n            message: `Request to ${getRequestUrl(input)} failed with status ${status}`,\n            error: json\n        })), effect_Effect__WEBPACK_IMPORTED_MODULE_3__.map(({ json })=>json), effect_Effect__WEBPACK_IMPORTED_MODULE_3__.andThen(_effect_schema_Schema__WEBPACK_IMPORTED_MODULE_1__.decode(schema)), effect_Effect__WEBPACK_IMPORTED_MODULE_3__.withSpan(\"fetchJson\", {\n        attributes: {\n            input: JSON.stringify(input)\n        }\n    }));\n};\nconst parseRequestJson = (reqOrRes, schema)=>effect_Effect__WEBPACK_IMPORTED_MODULE_3__.tryPromise({\n        try: ()=>reqOrRes.json(),\n        catch: (error)=>new FetchError({\n                error,\n                input: \"url\" in reqOrRes ? reqOrRes.url : `Response ${reqOrRes.status} - ${reqOrRes.statusText}`\n            })\n    }).pipe(effect_Effect__WEBPACK_IMPORTED_MODULE_3__.andThen(_effect_schema_Schema__WEBPACK_IMPORTED_MODULE_1__.decode(schema)));\n/**\n * Schedule that retries with exponential backoff, up to 1 minute.\n * 10ms * 4^n, where n is the number of retries.\n */ const exponentialBackoff = (0,effect_Function__WEBPACK_IMPORTED_MODULE_6__.pipe)(effect_Schedule__WEBPACK_IMPORTED_MODULE_7__.exponential(effect_Duration__WEBPACK_IMPORTED_MODULE_8__.millis(10), 4), effect_Schedule__WEBPACK_IMPORTED_MODULE_7__.andThenEither(effect_Schedule__WEBPACK_IMPORTED_MODULE_7__.spaced(effect_Duration__WEBPACK_IMPORTED_MODULE_8__.seconds(1))), effect_Schedule__WEBPACK_IMPORTED_MODULE_7__.compose(effect_Schedule__WEBPACK_IMPORTED_MODULE_7__.elapsed), effect_Schedule__WEBPACK_IMPORTED_MODULE_7__.whileOutput(effect_Duration__WEBPACK_IMPORTED_MODULE_8__.lessThanOrEqualTo(effect_Duration__WEBPACK_IMPORTED_MODULE_8__.minutes(1))));\n\nconst generateMimeTypes = (fileTypes)=>{\n    const accepted = fileTypes.map((type)=>{\n        if (type === \"blob\") return \"blob\";\n        if (type === \"pdf\") return \"application/pdf\";\n        if (type.includes(\"/\")) return type;\n        else return `${type}/*`;\n    });\n    if (accepted.includes(\"blob\")) {\n        return [];\n    }\n    return accepted;\n};\nconst generateClientDropzoneAccept = (fileTypes)=>{\n    const mimeTypes = generateMimeTypes(fileTypes);\n    return Object.fromEntries(mimeTypes.map((type)=>[\n            type,\n            []\n        ]));\n};\nfunction getFilesFromClipboardEvent(event) {\n    const dataTransferItems = event.clipboardData?.items;\n    if (!dataTransferItems) return;\n    const files = Array.from(dataTransferItems).reduce((acc, curr)=>{\n        const f = curr.getAsFile();\n        return f ? [\n            ...acc,\n            f\n        ] : acc;\n    }, []);\n    return files;\n}\n/**\n * Shared helpers for our premade components that's reusable by multiple frameworks\n */ const generatePermittedFileTypes = (config)=>{\n    const fileTypes = config ? objectKeys(config) : [];\n    const maxFileCount = config ? Object.values(config).map((v)=>v.maxFileCount) : [];\n    return {\n        fileTypes,\n        multiple: maxFileCount.some((v)=>v && v > 1)\n    };\n};\nconst capitalizeStart = (str)=>{\n    return str.charAt(0).toUpperCase() + str.slice(1);\n};\nconst INTERNAL_doFormatting = (config)=>{\n    if (!config) return \"\";\n    const allowedTypes = objectKeys(config);\n    const formattedTypes = allowedTypes.map((f)=>f === \"blob\" ? \"file\" : f);\n    // Format multi-type uploader label as \"Supports videos, images and files\";\n    if (formattedTypes.length > 1) {\n        const lastType = formattedTypes.pop();\n        return `${formattedTypes.join(\"s, \")} and ${lastType}s`;\n    }\n    // Single type uploader label\n    const key = allowedTypes[0];\n    const formattedKey = formattedTypes[0];\n    const { maxFileSize, maxFileCount, minFileCount } = config[key];\n    if (maxFileCount && maxFileCount > 1) {\n        if (minFileCount > 1) {\n            return `${minFileCount} - ${maxFileCount} ${formattedKey}s up to ${maxFileSize}`;\n        } else {\n            return `${formattedKey}s up to ${maxFileSize}, max ${maxFileCount}`;\n        }\n    } else {\n        return `${formattedKey} (${maxFileSize})`;\n    }\n};\nconst allowedContentTextLabelGenerator = (config)=>{\n    return capitalizeStart(INTERNAL_doFormatting(config));\n};\nconst styleFieldToClassName = (styleField, args)=>{\n    if (typeof styleField === \"string\") return styleField;\n    if (typeof styleField === \"function\") {\n        const result = styleField(args);\n        if (typeof result === \"string\") return result;\n    }\n    return \"\";\n};\nconst styleFieldToCssObject = (styleField, args)=>{\n    if (typeof styleField === \"object\") return styleField;\n    if (typeof styleField === \"function\") {\n        const result = styleField(args);\n        if (typeof result === \"object\") return result;\n    }\n    return {};\n};\nconst contentFieldToContent = (contentField, arg)=>{\n    if (!contentField) return null;\n    if (typeof contentField !== \"function\") return contentField;\n    if (typeof contentField === \"function\") {\n        const result = contentField(arg);\n        return result;\n    }\n};\n\nconst signaturePrefix = \"hmac-sha256=\";\nconst algorithm = {\n    name: \"HMAC\",\n    hash: \"SHA-256\"\n};\nconst signPayload = async (payload, secret)=>{\n    const encoder = new TextEncoder();\n    const signingKey = await crypto.subtle.importKey(\"raw\", encoder.encode(secret), algorithm, false, [\n        \"sign\"\n    ]);\n    const signature = await crypto.subtle.sign(algorithm, signingKey, encoder.encode(payload)).then((sig)=>Buffer.from(sig).toString(\"hex\"));\n    return `${signaturePrefix}${signature}`;\n};\nconst verifySignature = async (payload, signature, secret)=>{\n    const sig = signature?.slice(signaturePrefix.length);\n    if (!sig) return false;\n    const encoder = new TextEncoder();\n    const signingKey = await crypto.subtle.importKey(\"raw\", encoder.encode(secret), algorithm, false, [\n        \"verify\"\n    ]);\n    return await crypto.subtle.verify(algorithm, signingKey, Uint8Array.from(Buffer.from(sig, \"hex\")), encoder.encode(payload));\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHVwbG9hZHRoaW5nK3NoYXJlZEA2LjcuM19AdXBsb2FkdGhpbmcrbWltZS10eXBlc0AwLjIuOS9ub2RlX21vZHVsZXMvQHVwbG9hZHRoaW5nL3NoYXJlZC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEyQztBQUNIO0FBQ047QUFDZTtBQUNQO0FBQ0E7QUFDRTtBQUNMO0FBQ0s7O0FBRTVDLGlDQUFpQywwREFBUztBQUMxQyxrQkFBa0IsMERBQVM7O0FBRTNCLHNDQUFzQyx3REFBVztBQUNqRDtBQUNBLGtFQUFrRSxPQUFPLFVBQVUsTUFBTSxrRkFBa0YsTUFBTTtBQUNqTDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQ0FBbUMsd0RBQVc7QUFDOUM7QUFDQSx1REFBdUQsU0FBUztBQUNoRTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQ0FBbUMsd0RBQVc7QUFDOUM7QUFDQSxvQ0FBb0MsVUFBVSxrQkFBa0IsU0FBUztBQUN6RTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQ0FBbUMsd0RBQVc7QUFDOUM7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw4QkFBOEIsd0RBQVc7QUFDekM7QUFDQTtBQUNBLHdDQUF3QyxhQUFhO0FBQ3JELFNBQVM7QUFDVDtBQUNBO0FBQ0EseUJBQXlCLHdEQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix3REFBVztBQUNwQztBQUNBLDhCQUE4Qix3REFBVztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0IsRUFBRSxVQUFVO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVzK0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXNlY29icmEvLi9ub2RlX21vZHVsZXMvLnBucG0vQHVwbG9hZHRoaW5nK3NoYXJlZEA2LjcuM19AdXBsb2FkdGhpbmcrbWltZS10eXBlc0AwLjIuOS9ub2RlX21vZHVsZXMvQHVwbG9hZHRoaW5nL3NoYXJlZC9kaXN0L2luZGV4LmpzP2I0NDIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUyBmcm9tICdAZWZmZWN0L3NjaGVtYS9TY2hlbWEnO1xuaW1wb3J0ICogYXMgRWZmZWN0IGZyb20gJ2VmZmVjdC9FZmZlY3QnO1xuaW1wb3J0IHsgcHJvY2VzcyB9IGZyb20gJ3N0ZC1lbnYnO1xuaW1wb3J0IHsgbG9va3VwIH0gZnJvbSAnQHVwbG9hZHRoaW5nL21pbWUtdHlwZXMnO1xuaW1wb3J0IHsgVGFnZ2VkRXJyb3IgfSBmcm9tICdlZmZlY3QvRGF0YSc7XG5pbXBvcnQgKiBhcyBDb250ZXh0IGZyb20gJ2VmZmVjdC9Db250ZXh0JztcbmltcG9ydCAqIGFzIER1cmF0aW9uIGZyb20gJ2VmZmVjdC9EdXJhdGlvbic7XG5pbXBvcnQgeyBwaXBlIH0gZnJvbSAnZWZmZWN0L0Z1bmN0aW9uJztcbmltcG9ydCAqIGFzIFNjaGVkdWxlIGZyb20gJ2VmZmVjdC9TY2hlZHVsZSc7XG5cbmNvbnN0IENvbnRlbnREaXNwb3NpdGlvblNjaGVtYSA9IFMuTGl0ZXJhbChcImlubGluZVwiLCBcImF0dGFjaG1lbnRcIik7XG5jb25zdCBBQ0xTY2hlbWEgPSBTLkxpdGVyYWwoXCJwdWJsaWMtcmVhZFwiLCBcInByaXZhdGVcIik7XG5cbmNsYXNzIEludmFsaWRSb3V0ZUNvbmZpZ0Vycm9yIGV4dGVuZHMgVGFnZ2VkRXJyb3IoXCJJbnZhbGlkUm91dGVDb25maWdcIikge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGZpZWxkKXtcbiAgICAgICAgY29uc3QgcmVhc29uID0gZmllbGQgPyBgRXhwZWN0ZWQgcm91dGUgY29uZmlnIHRvIGhhdmUgYSAke2ZpZWxkfSBmb3Iga2V5ICR7dHlwZX0gYnV0IG5vbmUgd2FzIGZvdW5kLmAgOiBgRW5jb3VudGVyZWQgYW4gaW52YWxpZCByb3V0ZSBjb25maWcgZHVyaW5nIGJhY2tmaWxsaW5nLiAke3R5cGV9IHdhcyBub3QgZm91bmQuYDtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgcmVhc29uXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFVua25vd25GaWxlVHlwZUVycm9yIGV4dGVuZHMgVGFnZ2VkRXJyb3IoXCJVbmtub3duRmlsZVR5cGVcIikge1xuICAgIGNvbnN0cnVjdG9yKGZpbGVOYW1lKXtcbiAgICAgICAgY29uc3QgcmVhc29uID0gYENvdWxkIG5vdCBkZXRlcm1pbmUgdHlwZSBmb3IgJHtmaWxlTmFtZX1gO1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICByZWFzb25cbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgSW52YWxpZEZpbGVUeXBlRXJyb3IgZXh0ZW5kcyBUYWdnZWRFcnJvcihcIkludmFsaWRGaWxlVHlwZVwiKSB7XG4gICAgY29uc3RydWN0b3IoZmlsZVR5cGUsIGZpbGVOYW1lKXtcbiAgICAgICAgY29uc3QgcmVhc29uID0gYEZpbGUgdHlwZSAke2ZpbGVUeXBlfSBub3QgYWxsb3dlZCBmb3IgJHtmaWxlTmFtZX1gO1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICByZWFzb25cbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgSW52YWxpZEZpbGVTaXplRXJyb3IgZXh0ZW5kcyBUYWdnZWRFcnJvcihcIkludmFsaWRGaWxlU2l6ZVwiKSB7XG4gICAgY29uc3RydWN0b3IoZmlsZVNpemUpe1xuICAgICAgICBjb25zdCByZWFzb24gPSBgSW52YWxpZCBmaWxlIHNpemU6ICR7ZmlsZVNpemV9YDtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgcmVhc29uXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIEludmFsaWRVUkxFcnJvciBleHRlbmRzIFRhZ2dlZEVycm9yKFwiSW52YWxpZFVSTFwiKSB7XG4gICAgY29uc3RydWN0b3IoYXR0ZW1wdGVkVXJsKXtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgcmVhc29uOiBgRmFpbGVkIHRvIHBhcnNlICcke2F0dGVtcHRlZFVybH0nIGFzIGEgVVJMLmBcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgUmV0cnlFcnJvciBleHRlbmRzIFRhZ2dlZEVycm9yKFwiUmV0cnlFcnJvclwiKSB7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovIGNvbnN0IGdldFJlcXVlc3RVcmwgPSAoaW5wdXQpPT57XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgICAgICByZXR1cm4gaW5wdXQudXJsO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXQudG9TdHJpbmcoKTtcbn07XG5jbGFzcyBGZXRjaEVycm9yIGV4dGVuZHMgVGFnZ2VkRXJyb3IoXCJGZXRjaEVycm9yXCIpIHtcbn1cbmNsYXNzIEJhZFJlcXVlc3RFcnJvciBleHRlbmRzIFRhZ2dlZEVycm9yKFwiQmFkUmVxdWVzdEVycm9yXCIpIHtcbiAgICBnZXRNZXNzYWdlKCkge1xuICAgICAgICBpZiAoaXNPYmplY3QodGhpcy5lcnJvcikpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5lcnJvci5tZXNzYWdlID09PSBcInN0cmluZ1wiKSByZXR1cm4gdGhpcy5lcnJvci5tZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc1JvdXRlQXJyYXkocm91dGVDb25maWcpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShyb3V0ZUNvbmZpZyk7XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0U2l6ZUZvclR5cGUoZmlsZVR5cGUpIHtcbiAgICBpZiAoZmlsZVR5cGUgPT09IFwiaW1hZ2VcIikgcmV0dXJuIFwiNE1CXCI7XG4gICAgaWYgKGZpbGVUeXBlID09PSBcInZpZGVvXCIpIHJldHVybiBcIjE2TUJcIjtcbiAgICBpZiAoZmlsZVR5cGUgPT09IFwiYXVkaW9cIikgcmV0dXJuIFwiOE1CXCI7XG4gICAgaWYgKGZpbGVUeXBlID09PSBcImJsb2JcIikgcmV0dXJuIFwiOE1CXCI7XG4gICAgaWYgKGZpbGVUeXBlID09PSBcInBkZlwiKSByZXR1cm4gXCI0TUJcIjtcbiAgICBpZiAoZmlsZVR5cGUgPT09IFwidGV4dFwiKSByZXR1cm4gXCI2NEtCXCI7XG4gICAgcmV0dXJuIFwiNE1CXCI7XG59XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgaW4gdGhlIHVzZXIncyBpbnB1dCBhbmQgXCJ1cHNjYWxlc1wiIGl0IHRvIGEgZnVsbCBjb25maWdcbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgdHNcbiAqIFtcImltYWdlXCJdID0+IHsgaW1hZ2U6IHsgbWF4RmlsZVNpemU6IFwiNE1CXCIsIGxpbWl0OiAxIH0gfVxuICogYGBgXG4gKi8gY29uc3QgZmlsbElucHV0Um91dGVDb25maWcgPSAocm91dGVDb25maWcpPT57XG4gICAgLy8gSWYgYXJyYXksIGFwcGx5IGRlZmF1bHRzXG4gICAgaWYgKGlzUm91dGVBcnJheShyb3V0ZUNvbmZpZykpIHtcbiAgICAgICAgcmV0dXJuIEVmZmVjdC5zdWNjZWVkKHJvdXRlQ29uZmlnLnJlZHVjZSgoYWNjLCBmaWxlVHlwZSk9PntcbiAgICAgICAgICAgIGFjY1tmaWxlVHlwZV0gPSB7XG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgZGVmYXVsdHNcbiAgICAgICAgICAgICAgICBtYXhGaWxlU2l6ZTogZ2V0RGVmYXVsdFNpemVGb3JUeXBlKGZpbGVUeXBlKSxcbiAgICAgICAgICAgICAgICBtYXhGaWxlQ291bnQ6IDEsXG4gICAgICAgICAgICAgICAgbWluRmlsZUNvdW50OiAxLFxuICAgICAgICAgICAgICAgIGNvbnRlbnREaXNwb3NpdGlvbjogXCJpbmxpbmVcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9KSk7XG4gICAgfVxuICAgIC8vIEJhY2tmaWxsIGRlZmF1bHRzIG9udG8gY29uZmlnXG4gICAgY29uc3QgbmV3Q29uZmlnID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgb2Ygb2JqZWN0S2V5cyhyb3V0ZUNvbmZpZykpe1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHJvdXRlQ29uZmlnW2tleV07XG4gICAgICAgIGlmICghdmFsdWUpIHJldHVybiBFZmZlY3QuZmFpbChuZXcgSW52YWxpZFJvdXRlQ29uZmlnRXJyb3Ioa2V5KSk7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZXMgPSB7XG4gICAgICAgICAgICBtYXhGaWxlU2l6ZTogZ2V0RGVmYXVsdFNpemVGb3JUeXBlKGtleSksXG4gICAgICAgICAgICBtYXhGaWxlQ291bnQ6IDEsXG4gICAgICAgICAgICBtaW5GaWxlQ291bnQ6IDEsXG4gICAgICAgICAgICBjb250ZW50RGlzcG9zaXRpb246IFwiaW5saW5lXCJcbiAgICAgICAgfTtcbiAgICAgICAgbmV3Q29uZmlnW2tleV0gPSB7XG4gICAgICAgICAgICAuLi5kZWZhdWx0VmFsdWVzLFxuICAgICAgICAgICAgLi4udmFsdWVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIEVmZmVjdC5zdWNjZWVkKG5ld0NvbmZpZyk7XG59O1xuY29uc3QgZ2V0VHlwZUZyb21GaWxlTmFtZSA9IChmaWxlTmFtZSwgYWxsb3dlZFR5cGVzKT0+e1xuICAgIGNvbnN0IG1pbWVUeXBlID0gbG9va3VwKGZpbGVOYW1lKTtcbiAgICBpZiAoIW1pbWVUeXBlKSB7XG4gICAgICAgIGlmIChhbGxvd2VkVHlwZXMuaW5jbHVkZXMoXCJibG9iXCIpKSByZXR1cm4gRWZmZWN0LnN1Y2NlZWQoXCJibG9iXCIpO1xuICAgICAgICByZXR1cm4gRWZmZWN0LmZhaWwobmV3IFVua25vd25GaWxlVHlwZUVycm9yKGZpbGVOYW1lKSk7XG4gICAgfVxuICAgIC8vIElmIHRoZSB1c2VyIGhhcyBzcGVjaWZpZWQgYSBzcGVjaWZpYyBtaW1lIHR5cGUsIHVzZSB0aGF0XG4gICAgaWYgKGFsbG93ZWRUeXBlcy5zb21lKCh0eXBlKT0+dHlwZS5pbmNsdWRlcyhcIi9cIikpKSB7XG4gICAgICAgIGlmIChhbGxvd2VkVHlwZXMuaW5jbHVkZXMobWltZVR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gRWZmZWN0LnN1Y2NlZWQobWltZVR5cGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE90aGVyd2lzZSwgd2UgaGF2ZSBhIFwibWFnaWNcIiB0eXBlIGVnLiBcImltYWdlXCIgb3IgXCJ2aWRlb1wiXG4gICAgY29uc3QgdHlwZSA9IG1pbWVUeXBlLnRvTG93ZXJDYXNlKCkgPT09IFwiYXBwbGljYXRpb24vcGRmXCIgPyBcInBkZlwiIDogbWltZVR5cGUuc3BsaXQoXCIvXCIpWzBdO1xuICAgIGlmICghYWxsb3dlZFR5cGVzLmluY2x1ZGVzKHR5cGUpKSB7XG4gICAgICAgIC8vIEJsb2IgaXMgYSBjYXRjaC1hbGwgZm9yIGFueSBmaWxlIHR5cGUgbm90IGV4cGxpY2l0bHkgc3VwcG9ydGVkXG4gICAgICAgIGlmIChhbGxvd2VkVHlwZXMuaW5jbHVkZXMoXCJibG9iXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gRWZmZWN0LnN1Y2NlZWQoXCJibG9iXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEVmZmVjdC5mYWlsKG5ldyBJbnZhbGlkRmlsZVR5cGVFcnJvcih0eXBlLCBmaWxlTmFtZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBFZmZlY3Quc3VjY2VlZCh0eXBlKTtcbn07XG5mdW5jdGlvbiBnZW5lcmF0ZVVwbG9hZFRoaW5nVVJMKHBhdGgpIHtcbiAgICBsZXQgaG9zdCA9IFwiaHR0cHM6Ly91cGxvYWR0aGluZy5jb21cIjtcbiAgICBpZiAocHJvY2Vzcy5lbnYuQ1VTVE9NX0lORlJBX1VSTCkge1xuICAgICAgICBob3N0ID0gcHJvY2Vzcy5lbnYuQ1VTVE9NX0lORlJBX1VSTDtcbiAgICB9XG4gICAgcmV0dXJuIGAke2hvc3R9JHtwYXRofWA7XG59XG5jb25zdCBGSUxFU0laRV9VTklUUyA9IFtcbiAgICBcIkJcIixcbiAgICBcIktCXCIsXG4gICAgXCJNQlwiLFxuICAgIFwiR0JcIlxuXTtcbmNvbnN0IGZpbGVTaXplVG9CeXRlcyA9IChmaWxlU2l6ZSk9PntcbiAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoYF4oXFxcXGQrKShcXFxcLlxcXFxkKyk/XFxcXHMqKCR7RklMRVNJWkVfVU5JVFMuam9pbihcInxcIil9KSRgLCBcImlcIik7XG4gICAgLy8gbWFrZSBzdXJlIHRoZSBzdHJpbmcgaXMgaW4gdGhlIGZvcm1hdCBvZiAxMjNLQlxuICAgIGNvbnN0IG1hdGNoID0gZmlsZVNpemUubWF0Y2gocmVnZXgpO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIEVmZmVjdC5mYWlsKG5ldyBJbnZhbGlkRmlsZVNpemVFcnJvcihmaWxlU2l6ZSkpO1xuICAgIH1cbiAgICBjb25zdCBzaXplVmFsdWUgPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgICBjb25zdCBzaXplVW5pdCA9IG1hdGNoWzNdLnRvVXBwZXJDYXNlKCk7XG4gICAgY29uc3QgYnl0ZXMgPSBzaXplVmFsdWUgKiBNYXRoLnBvdygxMDI0LCBGSUxFU0laRV9VTklUUy5pbmRleE9mKHNpemVVbml0KSk7XG4gICAgcmV0dXJuIEVmZmVjdC5zdWNjZWVkKE1hdGguZmxvb3IoYnl0ZXMpKTtcbn07XG5jb25zdCBieXRlc1RvRmlsZVNpemUgPSAoYnl0ZXMpPT57XG4gICAgaWYgKGJ5dGVzID09PSAwIHx8IGJ5dGVzID09PSAtMSkge1xuICAgICAgICByZXR1cm4gXCIwQlwiO1xuICAgIH1cbiAgICBjb25zdCBpID0gTWF0aC5mbG9vcihNYXRoLmxvZyhieXRlcykgLyBNYXRoLmxvZygxMDAwKSk7XG4gICAgcmV0dXJuIGAkeyhieXRlcyAvIE1hdGgucG93KDEwMDAsIGkpKS50b0ZpeGVkKDIpfSR7RklMRVNJWkVfVU5JVFNbaV19YDtcbn07XG5hc3luYyBmdW5jdGlvbiBzYWZlUGFyc2VKU09OKGlucHV0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoaW5wdXQpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHBhcnNpbmcgSlNPTiwgZ290ICcke2lucHV0fSdgKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoYEVycm9yIHBhcnNpbmcgSlNPTiwgZ290ICcke2lucHV0fSdgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0ZXh0ID0gYXdhaXQgaW5wdXQudGV4dCgpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRleHQgPz8gXCJudWxsXCIpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBwYXJzaW5nIEpTT04sIGdvdCAnJHt0ZXh0fSdgKTtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgRXJyb3IgcGFyc2luZyBKU09OLCBnb3QgJyR7dGV4dH0nYCk7XG4gICAgfVxufVxuLyoqIHR5cGVzYWZlIE9iamVjdC5rZXlzICovIGZ1bmN0aW9uIG9iamVjdEtleXMob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaik7XG59XG4vKiogY2hlY2tzIGlmIG9iaiBpcyBhIHZhbGlkLCBub24tbnVsbCBvYmplY3QgKi8gZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgb2JqICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KG9iaik7XG59XG5mdW5jdGlvbiBhc0FycmF5KHZhbCkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbCkgPyB2YWwgOiBbXG4gICAgICAgIHZhbFxuICAgIF07XG59XG4vKipcbiAqIEZpbHRlcnMgYW4gb2JqZWN0J3MgdmFsdWVzIGJhc2VkIG9uIGEgcHJlZGljYXRlXG4gKiBAZXhhbXBsZVxuICogZmlsdGVyT2JqZWN0VmFsdWVzKHsgYTogXCJhXCIsIGI6IG51bGwgfSwgKHYpOiB2IGlzIHN0cmluZyA9PiB2ICE9IG51bGwpXG4gKiAvLyBePyBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHsgYTogXCJhXCIgfVxuICovIGNvbnN0IGZpbHRlck9iamVjdFZhbHVlcyA9IChvYmosIHByZWRpY2F0ZSk9PntcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKG9iaikuZmlsdGVyKChbXywgdl0pPT5wcmVkaWNhdGUodikpKTtcbn07XG4vKiogY29uc3RydWN0IGNvbnRlbnQtZGlzcG9zaXRpb24gaGVhZGVyICovIGZ1bmN0aW9uIGNvbnRlbnREaXNwb3NpdGlvbihjb250ZW50RGlzcG9zaXRpb24sIGZpbGVOYW1lKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgY29udGVudERpc3Bvc2l0aW9uLFxuICAgICAgICBgZmlsZW5hbWU9XCIke2VuY29kZVVSSShmaWxlTmFtZSl9XCJgLFxuICAgICAgICBgZmlsZW5hbWUqPVVURi04Jycke2VuY29kZVVSSShmaWxlTmFtZSl9YFxuICAgIF0uam9pbihcIjsgXCIpO1xufVxuZnVuY3Rpb24gc2VtdmVyTGl0ZShyZXF1aXJlZCwgdG9DaGVjaykge1xuICAgIC8vIFB1bGwgb3V0IG51bWJlcnMgZnJvbSBzdHJpbmdzIGxpa2UgYDYuMC4wYCwgYF42LjRgLCBgfjYuNC4wYFxuICAgIGNvbnN0IHNlbXZlclJlZ2V4ID0gLyhcXGQrKVxcLj8oXFxkKyk/XFwuPyhcXGQrKT8vO1xuICAgIGNvbnN0IHJlcXVpcmVkTWF0Y2ggPSByZXF1aXJlZC5tYXRjaChzZW12ZXJSZWdleCk7XG4gICAgaWYgKCFyZXF1aXJlZE1hdGNoPy5bMF0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNlbXZlciByZXF1aXJlbWVudDogJHtyZXF1aXJlZH1gKTtcbiAgICB9XG4gICAgY29uc3QgdG9DaGVja01hdGNoID0gdG9DaGVjay5tYXRjaChzZW12ZXJSZWdleCk7XG4gICAgaWYgKCF0b0NoZWNrTWF0Y2g/LlswXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2VtdmVyIHRvIGNoZWNrOiAke3RvQ2hlY2t9YCk7XG4gICAgfVxuICAgIGNvbnN0IFtfMSwgck1ham9yLCByTWlub3IsIHJQYXRjaF0gPSByZXF1aXJlZE1hdGNoO1xuICAgIGNvbnN0IFtfMiwgY01ham9yLCBjTWlub3IsIGNQYXRjaF0gPSB0b0NoZWNrTWF0Y2g7XG4gICAgaWYgKHJlcXVpcmVkLnN0YXJ0c1dpdGgoXCJeXCIpKSB7XG4gICAgICAgIC8vIE1ham9yIG11c3QgYmUgZXF1YWwsIG1pbm9yIG11c3QgYmUgZ3JlYXRlciBvciBlcXVhbFxuICAgICAgICBpZiAock1ham9yICE9PSBjTWFqb3IpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHJNaW5vciA+IGNNaW5vcikgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHJlcXVpcmVkLnN0YXJ0c1dpdGgoXCJ+XCIpKSB7XG4gICAgICAgIC8vIE1ham9yIG11c3QgYmUgZXF1YWwsIG1pbm9yIG11c3QgYmUgZXF1YWxcbiAgICAgICAgaWYgKHJNYWpvciAhPT0gY01ham9yKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChyTWlub3IgIT09IGNNaW5vcikgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gRXhhY3QgbWF0Y2hcbiAgICByZXR1cm4gck1ham9yID09PSBjTWFqb3IgJiYgck1pbm9yID09PSBjTWlub3IgJiYgclBhdGNoID09PSBjUGF0Y2g7XG59XG5jb25zdCBnZXRGdWxsQXBpVXJsID0gKG1heWJlVXJsKT0+RWZmZWN0LmdlbihmdW5jdGlvbiooKSB7XG4gICAgICAgIGNvbnN0IGJhc2UgPSAoKCk9PntcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gd2luZG93LmxvY2F0aW9uLm9yaWdpbjtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudj8uVkVSQ0VMX1VSTCkgcmV0dXJuIGBodHRwczovLyR7cHJvY2Vzcy5lbnYuVkVSQ0VMX1VSTH1gO1xuICAgICAgICAgICAgcmV0dXJuIFwiaHR0cDovL2xvY2FsaG9zdDozMDAwXCI7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIGNvbnN0IHVybCA9IHlpZWxkKiBFZmZlY3QudHJ5KHtcbiAgICAgICAgICAgIHRyeTogKCk9Pm5ldyBVUkwobWF5YmVVcmwgPz8gXCIvYXBpL3VwbG9hZHRoaW5nXCIsIGJhc2UpLFxuICAgICAgICAgICAgY2F0Y2g6ICgpPT5uZXcgSW52YWxpZFVSTEVycm9yKG1heWJlVXJsID8/IFwiL2FwaS91cGxvYWR0aGluZ1wiKVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHVybC5wYXRobmFtZSA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAgIHVybC5wYXRobmFtZSA9IFwiL2FwaS91cGxvYWR0aGluZ1wiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfSk7XG4vKlxuICogUmV0dXJucyBhIGZ1bGwgVVJMIHRvIHRoZSBkZXYncyB1cGxvYWR0aGluZyBlbmRwb2ludFxuICogQ2FuIHRha2UgZWl0aGVyIGFuIG9yaWdpbiwgb3IgYSBwYXRobmFtZSwgb3IgYSBmdWxsIFVSTFxuICogYW5kIHdpbGwgcmV0dXJuIHRoZSBcImNsb3Nlc3RcIiB1cmwgbWF0Y2hpbmcgdGhlIGRlZmF1bHRcbiAqIGA8VkVSQ0VMX1VSTCB8fCBsb2NhbGhvc3Q+L2FwaS91cGxvYWR0aGluZ2BcbiAqLyBjb25zdCByZXNvbHZlTWF5YmVVcmxBcmcgPSAobWF5YmVVcmwpPT57XG4gICAgcmV0dXJuIG1heWJlVXJsIGluc3RhbmNlb2YgVVJMID8gbWF5YmVVcmwgOiBFZmZlY3QucnVuU3luYyhnZXRGdWxsQXBpVXJsKG1heWJlVXJsKSk7XG59O1xuXG5jb25zdCBBTExPV0VEX0ZJTEVfVFlQRVMgPSBbXG4gICAgXCJpbWFnZVwiLFxuICAgIFwidmlkZW9cIixcbiAgICBcImF1ZGlvXCIsXG4gICAgXCJwZGZcIixcbiAgICBcInRleHRcIixcbiAgICBcImJsb2JcIlxuXTtcblxuY29uc3QgRVJST1JfQ09ERVMgPSB7XG4gICAgLy8gR2VuZXJpY1xuICAgIEJBRF9SRVFVRVNUOiA0MDAsXG4gICAgTk9UX0ZPVU5EOiA0MDQsXG4gICAgRk9SQklEREVOOiA0MDMsXG4gICAgSU5URVJOQUxfU0VSVkVSX0VSUk9SOiA1MDAsXG4gICAgSU5URVJOQUxfQ0xJRU5UX0VSUk9SOiA1MDAsXG4gICAgLy8gUzMgc3BlY2lmaWNcbiAgICBUT09fTEFSR0U6IDQxMyxcbiAgICBUT09fU01BTEw6IDQwMCxcbiAgICBUT09fTUFOWV9GSUxFUzogNDAwLFxuICAgIEtFWV9UT09fTE9ORzogNDAwLFxuICAgIC8vIFVwbG9hZFRoaW5nIHNwZWNpZmljXG4gICAgVVJMX0dFTkVSQVRJT05fRkFJTEVEOiA1MDAsXG4gICAgVVBMT0FEX0ZBSUxFRDogNTAwLFxuICAgIE1JU1NJTkdfRU5WOiA1MDAsXG4gICAgRklMRV9MSU1JVF9FWENFRURFRDogNTAwXG59O1xuZnVuY3Rpb24gbWVzc2FnZUZyb21Vbmtub3duKGNhdXNlLCBmYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgY2F1c2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGNhdXNlO1xuICAgIH1cbiAgICBpZiAoY2F1c2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gY2F1c2UubWVzc2FnZTtcbiAgICB9XG4gICAgaWYgKGNhdXNlICYmIHR5cGVvZiBjYXVzZSA9PT0gXCJvYmplY3RcIiAmJiBcIm1lc3NhZ2VcIiBpbiBjYXVzZSAmJiB0eXBlb2YgY2F1c2UubWVzc2FnZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gY2F1c2UubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbGxiYWNrID8/IFwiQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZFwiO1xufVxuY2xhc3MgVXBsb2FkVGhpbmdFcnJvciBleHRlbmRzIFRhZ2dlZEVycm9yKFwiVXBsb2FkVGhpbmdFcnJvclwiKSB7XG4gICAgY29uc3RydWN0b3IoaW5pdE9wdHMpe1xuICAgICAgICBjb25zdCBvcHRzID0gdHlwZW9mIGluaXRPcHRzID09PSBcInN0cmluZ1wiID8ge1xuICAgICAgICAgICAgY29kZTogXCJJTlRFUk5BTF9TRVJWRVJfRVJST1JcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGluaXRPcHRzXG4gICAgICAgIH0gOiBpbml0T3B0cztcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IG9wdHMubWVzc2FnZSA/PyBtZXNzYWdlRnJvbVVua25vd24ob3B0cy5jYXVzZSwgb3B0cy5jb2RlKTtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgbWVzc2FnZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb2RlID0gb3B0cy5jb2RlO1xuICAgICAgICB0aGlzLmRhdGEgPSBvcHRzLmRhdGE7XG4gICAgICAgIGlmIChvcHRzLmNhdXNlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuY2F1c2UgPSBvcHRzLmNhdXNlO1xuICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KG9wdHMuY2F1c2UpICYmIHR5cGVvZiBvcHRzLmNhdXNlLnN0YXR1cyA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2Ygb3B0cy5jYXVzZS5zdGF0dXNUZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLmNhdXNlID0gbmV3IEVycm9yKGBSZXNwb25zZSAke29wdHMuY2F1c2Uuc3RhdHVzfSAke29wdHMuY2F1c2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0cy5jYXVzZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhpcy5jYXVzZSA9IG5ldyBFcnJvcihvcHRzLmNhdXNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2F1c2UgPSBvcHRzLmNhdXNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyB0b09iamVjdChlcnJvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogZXJyb3IuY29kZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICBkYXRhOiBlcnJvci5kYXRhXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBzZXJpYWxpemUoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFVwbG9hZFRoaW5nRXJyb3IudG9PYmplY3QoZXJyb3IpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRFcnJvclR5cGVGcm9tU3RhdHVzQ29kZShzdGF0dXNDb2RlKSB7XG4gICAgZm9yIChjb25zdCBbY29kZSwgc3RhdHVzXSBvZiBPYmplY3QuZW50cmllcyhFUlJPUl9DT0RFUykpe1xuICAgICAgICBpZiAoc3RhdHVzID09PSBzdGF0dXNDb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gY29kZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCJJTlRFUk5BTF9TRVJWRVJfRVJST1JcIjtcbn1cbmZ1bmN0aW9uIGdldFN0YXR1c0NvZGVGcm9tRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gRVJST1JfQ09ERVNbZXJyb3IuY29kZV0gPz8gNTAwO1xufVxuY29uc3QgSU5URVJOQUxfRE9fTk9UX1VTRV9fZmF0YWxDbGllbnRFcnJvciA9IChlKT0+bmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICBjb2RlOiBcIklOVEVSTkFMX0NMSUVOVF9FUlJPUlwiLFxuICAgICAgICBtZXNzYWdlOiBcIlNvbWV0aGluZyB3ZW50IHdyb25nLiBQbGVhc2UgcmVwb3J0IHRoaXMgdG8gVXBsb2FkVGhpbmcuXCIsXG4gICAgICAgIGNhdXNlOiBlXG4gICAgfSk7XG5cbmNsYXNzIEZldGNoQ29udGV4dCBleHRlbmRzIENvbnRleHQuVGFnKFwidXBsb2FkdGhpbmcvRmV0Y2hDb250ZXh0XCIpKCkge1xufVxuLy8gVGVtcG9yYXJ5IEVmZmVjdCB3cmFwcGVycyBiZWxvdy5cbi8vIFRPRE8gc2hvdWxkIGJlIHJlZmFjdG9yZWQgd2l0aCBtdWNoIGxvdmVcbi8vIFRPRE8gaGFuZGxlIGVycm9yIHByb3Blcmx5XG5jb25zdCBmZXRjaEVmZiA9IChpbnB1dCwgaW5pdCk9PkZldGNoQ29udGV4dC5waXBlKEVmZmVjdC5hbmRUaGVuKCh7IGZldGNoLCBiYXNlSGVhZGVycyB9KT0+RWZmZWN0LnRyeVByb21pc2Uoe1xuICAgICAgICAgICAgdHJ5OiAoKT0+ZmV0Y2goaW5wdXQsIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uaW5pdCxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uZmlsdGVyT2JqZWN0VmFsdWVzKGJhc2VIZWFkZXJzLCAodik9PnYgIT0gbnVsbCksXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5pbml0Py5oZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGNhdGNoOiAoZXJyb3IpPT5uZXcgRmV0Y2hFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH0pKSwgRWZmZWN0LndpdGhTcGFuKFwiZmV0Y2hcIiwge1xuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICBpbnB1dDogSlNPTi5zdHJpbmdpZnkoaW5wdXQpXG4gICAgICAgIH1cbiAgICB9KSk7XG4vLyBUT0RPOiByZW5hbWUgdGhlIG90aGVyIG9uZSB0byBmZXRjaEVmZkpzb25TY2hlbWEgYW5kIHRoaXMgdG8gZmV0Y2hFZmZKc29uXG4vLyB0aG91Z2ggZ2VuZXJhbGx5IEkgd291bGQgYXZvaWQgWGFuZFkga2luZCB1dGlscyBpbiBmYXZvciBvZiBjb21wb3NpdGlvblxuY29uc3QgZmV0Y2hFZmZVbmtub3duID0gKGlucHV0LCAvKiogU2NoZW1hIHRvIGJlIHVzZWQgaWYgdGhlIHJlc3BvbnNlIHJldHVybmVkIGEgMnh4ICAqLyBpbml0KT0+e1xuICAgIGNvbnN0IHJlcXVlc3RVcmwgPSB0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIgPyBpbnB1dCA6IGlucHV0IGluc3RhbmNlb2YgVVJMID8gaW5wdXQudG9TdHJpbmcoKSA6IGlucHV0LnVybDtcbiAgICByZXR1cm4gZmV0Y2hFZmYoaW5wdXQsIGluaXQpLnBpcGUoRWZmZWN0LmFuZFRoZW4oKHJlcyk9PkVmZmVjdC50cnlQcm9taXNlKHtcbiAgICAgICAgICAgIHRyeTogYXN5bmMgKCk9PntcbiAgICAgICAgICAgICAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBqc29uLFxuICAgICAgICAgICAgICAgICAgICBvazogcmVzLm9rLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlcy5zdGF0dXNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhdGNoOiAoZXJyb3IpPT5uZXcgRmV0Y2hFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH0pKSwgRWZmZWN0LmZpbHRlck9yRmFpbCgoeyBvayB9KT0+b2ssICh7IGpzb24sIHN0YXR1cyB9KT0+bmV3IEJhZFJlcXVlc3RFcnJvcih7XG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBSZXF1ZXN0IHRvICR7cmVxdWVzdFVybH0gZmFpbGVkIHdpdGggc3RhdHVzICR7c3RhdHVzfWAsXG4gICAgICAgICAgICBlcnJvcjoganNvblxuICAgICAgICB9KSksIEVmZmVjdC53aXRoU3BhbihcImZldGNoUmF3SnNvblwiLCB7XG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIGlucHV0OiBKU09OLnN0cmluZ2lmeShpbnB1dClcbiAgICAgICAgfVxuICAgIH0pKTtcbn07XG5jb25zdCBmZXRjaEVmZkpzb24gPSAoaW5wdXQsIC8qKiBTY2hlbWEgdG8gYmUgdXNlZCBpZiB0aGUgcmVzcG9uc2UgcmV0dXJuZWQgYSAyeHggICovIHNjaGVtYSwgaW5pdCk9PntcbiAgICByZXR1cm4gZmV0Y2hFZmYoaW5wdXQsIGluaXQpLnBpcGUoRWZmZWN0LmFuZFRoZW4oKHJlcyk9PkVmZmVjdC50cnlQcm9taXNlKHtcbiAgICAgICAgICAgIHRyeTogYXN5bmMgKCk9PntcbiAgICAgICAgICAgICAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBvazogcmVzLm9rLFxuICAgICAgICAgICAgICAgICAgICBqc29uLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlcy5zdGF0dXNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhdGNoOiAoZXJyb3IpPT5uZXcgRmV0Y2hFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH0pKSwgRWZmZWN0LmZpbHRlck9yRmFpbCgoeyBvayB9KT0+b2ssICh7IGpzb24sIHN0YXR1cyB9KT0+bmV3IEJhZFJlcXVlc3RFcnJvcih7XG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBSZXF1ZXN0IHRvICR7Z2V0UmVxdWVzdFVybChpbnB1dCl9IGZhaWxlZCB3aXRoIHN0YXR1cyAke3N0YXR1c31gLFxuICAgICAgICAgICAgZXJyb3I6IGpzb25cbiAgICAgICAgfSkpLCBFZmZlY3QubWFwKCh7IGpzb24gfSk9Pmpzb24pLCBFZmZlY3QuYW5kVGhlbihTLmRlY29kZShzY2hlbWEpKSwgRWZmZWN0LndpdGhTcGFuKFwiZmV0Y2hKc29uXCIsIHtcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgaW5wdXQ6IEpTT04uc3RyaW5naWZ5KGlucHV0KVxuICAgICAgICB9XG4gICAgfSkpO1xufTtcbmNvbnN0IHBhcnNlUmVxdWVzdEpzb24gPSAocmVxT3JSZXMsIHNjaGVtYSk9PkVmZmVjdC50cnlQcm9taXNlKHtcbiAgICAgICAgdHJ5OiAoKT0+cmVxT3JSZXMuanNvbigpLFxuICAgICAgICBjYXRjaDogKGVycm9yKT0+bmV3IEZldGNoRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgIGlucHV0OiBcInVybFwiIGluIHJlcU9yUmVzID8gcmVxT3JSZXMudXJsIDogYFJlc3BvbnNlICR7cmVxT3JSZXMuc3RhdHVzfSAtICR7cmVxT3JSZXMuc3RhdHVzVGV4dH1gXG4gICAgICAgICAgICB9KVxuICAgIH0pLnBpcGUoRWZmZWN0LmFuZFRoZW4oUy5kZWNvZGUoc2NoZW1hKSkpO1xuLyoqXG4gKiBTY2hlZHVsZSB0aGF0IHJldHJpZXMgd2l0aCBleHBvbmVudGlhbCBiYWNrb2ZmLCB1cCB0byAxIG1pbnV0ZS5cbiAqIDEwbXMgKiA0Xm4sIHdoZXJlIG4gaXMgdGhlIG51bWJlciBvZiByZXRyaWVzLlxuICovIGNvbnN0IGV4cG9uZW50aWFsQmFja29mZiA9IHBpcGUoU2NoZWR1bGUuZXhwb25lbnRpYWwoRHVyYXRpb24ubWlsbGlzKDEwKSwgNCksIFNjaGVkdWxlLmFuZFRoZW5FaXRoZXIoU2NoZWR1bGUuc3BhY2VkKER1cmF0aW9uLnNlY29uZHMoMSkpKSwgU2NoZWR1bGUuY29tcG9zZShTY2hlZHVsZS5lbGFwc2VkKSwgU2NoZWR1bGUud2hpbGVPdXRwdXQoRHVyYXRpb24ubGVzc1RoYW5PckVxdWFsVG8oRHVyYXRpb24ubWludXRlcygxKSkpKTtcblxuY29uc3QgZ2VuZXJhdGVNaW1lVHlwZXMgPSAoZmlsZVR5cGVzKT0+e1xuICAgIGNvbnN0IGFjY2VwdGVkID0gZmlsZVR5cGVzLm1hcCgodHlwZSk9PntcbiAgICAgICAgaWYgKHR5cGUgPT09IFwiYmxvYlwiKSByZXR1cm4gXCJibG9iXCI7XG4gICAgICAgIGlmICh0eXBlID09PSBcInBkZlwiKSByZXR1cm4gXCJhcHBsaWNhdGlvbi9wZGZcIjtcbiAgICAgICAgaWYgKHR5cGUuaW5jbHVkZXMoXCIvXCIpKSByZXR1cm4gdHlwZTtcbiAgICAgICAgZWxzZSByZXR1cm4gYCR7dHlwZX0vKmA7XG4gICAgfSk7XG4gICAgaWYgKGFjY2VwdGVkLmluY2x1ZGVzKFwiYmxvYlwiKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBhY2NlcHRlZDtcbn07XG5jb25zdCBnZW5lcmF0ZUNsaWVudERyb3B6b25lQWNjZXB0ID0gKGZpbGVUeXBlcyk9PntcbiAgICBjb25zdCBtaW1lVHlwZXMgPSBnZW5lcmF0ZU1pbWVUeXBlcyhmaWxlVHlwZXMpO1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMobWltZVR5cGVzLm1hcCgodHlwZSk9PltcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBbXVxuICAgICAgICBdKSk7XG59O1xuZnVuY3Rpb24gZ2V0RmlsZXNGcm9tQ2xpcGJvYXJkRXZlbnQoZXZlbnQpIHtcbiAgICBjb25zdCBkYXRhVHJhbnNmZXJJdGVtcyA9IGV2ZW50LmNsaXBib2FyZERhdGE/Lml0ZW1zO1xuICAgIGlmICghZGF0YVRyYW5zZmVySXRlbXMpIHJldHVybjtcbiAgICBjb25zdCBmaWxlcyA9IEFycmF5LmZyb20oZGF0YVRyYW5zZmVySXRlbXMpLnJlZHVjZSgoYWNjLCBjdXJyKT0+e1xuICAgICAgICBjb25zdCBmID0gY3Vyci5nZXRBc0ZpbGUoKTtcbiAgICAgICAgcmV0dXJuIGYgPyBbXG4gICAgICAgICAgICAuLi5hY2MsXG4gICAgICAgICAgICBmXG4gICAgICAgIF0gOiBhY2M7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBmaWxlcztcbn1cbi8qKlxuICogU2hhcmVkIGhlbHBlcnMgZm9yIG91ciBwcmVtYWRlIGNvbXBvbmVudHMgdGhhdCdzIHJldXNhYmxlIGJ5IG11bHRpcGxlIGZyYW1ld29ya3NcbiAqLyBjb25zdCBnZW5lcmF0ZVBlcm1pdHRlZEZpbGVUeXBlcyA9IChjb25maWcpPT57XG4gICAgY29uc3QgZmlsZVR5cGVzID0gY29uZmlnID8gb2JqZWN0S2V5cyhjb25maWcpIDogW107XG4gICAgY29uc3QgbWF4RmlsZUNvdW50ID0gY29uZmlnID8gT2JqZWN0LnZhbHVlcyhjb25maWcpLm1hcCgodik9PnYubWF4RmlsZUNvdW50KSA6IFtdO1xuICAgIHJldHVybiB7XG4gICAgICAgIGZpbGVUeXBlcyxcbiAgICAgICAgbXVsdGlwbGU6IG1heEZpbGVDb3VudC5zb21lKCh2KT0+diAmJiB2ID4gMSlcbiAgICB9O1xufTtcbmNvbnN0IGNhcGl0YWxpemVTdGFydCA9IChzdHIpPT57XG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn07XG5jb25zdCBJTlRFUk5BTF9kb0Zvcm1hdHRpbmcgPSAoY29uZmlnKT0+e1xuICAgIGlmICghY29uZmlnKSByZXR1cm4gXCJcIjtcbiAgICBjb25zdCBhbGxvd2VkVHlwZXMgPSBvYmplY3RLZXlzKGNvbmZpZyk7XG4gICAgY29uc3QgZm9ybWF0dGVkVHlwZXMgPSBhbGxvd2VkVHlwZXMubWFwKChmKT0+ZiA9PT0gXCJibG9iXCIgPyBcImZpbGVcIiA6IGYpO1xuICAgIC8vIEZvcm1hdCBtdWx0aS10eXBlIHVwbG9hZGVyIGxhYmVsIGFzIFwiU3VwcG9ydHMgdmlkZW9zLCBpbWFnZXMgYW5kIGZpbGVzXCI7XG4gICAgaWYgKGZvcm1hdHRlZFR5cGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY29uc3QgbGFzdFR5cGUgPSBmb3JtYXR0ZWRUeXBlcy5wb3AoKTtcbiAgICAgICAgcmV0dXJuIGAke2Zvcm1hdHRlZFR5cGVzLmpvaW4oXCJzLCBcIil9IGFuZCAke2xhc3RUeXBlfXNgO1xuICAgIH1cbiAgICAvLyBTaW5nbGUgdHlwZSB1cGxvYWRlciBsYWJlbFxuICAgIGNvbnN0IGtleSA9IGFsbG93ZWRUeXBlc1swXTtcbiAgICBjb25zdCBmb3JtYXR0ZWRLZXkgPSBmb3JtYXR0ZWRUeXBlc1swXTtcbiAgICBjb25zdCB7IG1heEZpbGVTaXplLCBtYXhGaWxlQ291bnQsIG1pbkZpbGVDb3VudCB9ID0gY29uZmlnW2tleV07XG4gICAgaWYgKG1heEZpbGVDb3VudCAmJiBtYXhGaWxlQ291bnQgPiAxKSB7XG4gICAgICAgIGlmIChtaW5GaWxlQ291bnQgPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7bWluRmlsZUNvdW50fSAtICR7bWF4RmlsZUNvdW50fSAke2Zvcm1hdHRlZEtleX1zIHVwIHRvICR7bWF4RmlsZVNpemV9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgJHtmb3JtYXR0ZWRLZXl9cyB1cCB0byAke21heEZpbGVTaXplfSwgbWF4ICR7bWF4RmlsZUNvdW50fWA7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYCR7Zm9ybWF0dGVkS2V5fSAoJHttYXhGaWxlU2l6ZX0pYDtcbiAgICB9XG59O1xuY29uc3QgYWxsb3dlZENvbnRlbnRUZXh0TGFiZWxHZW5lcmF0b3IgPSAoY29uZmlnKT0+e1xuICAgIHJldHVybiBjYXBpdGFsaXplU3RhcnQoSU5URVJOQUxfZG9Gb3JtYXR0aW5nKGNvbmZpZykpO1xufTtcbmNvbnN0IHN0eWxlRmllbGRUb0NsYXNzTmFtZSA9IChzdHlsZUZpZWxkLCBhcmdzKT0+e1xuICAgIGlmICh0eXBlb2Ygc3R5bGVGaWVsZCA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHN0eWxlRmllbGQ7XG4gICAgaWYgKHR5cGVvZiBzdHlsZUZpZWxkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc3R5bGVGaWVsZChhcmdzKTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwic3RyaW5nXCIpIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBcIlwiO1xufTtcbmNvbnN0IHN0eWxlRmllbGRUb0Nzc09iamVjdCA9IChzdHlsZUZpZWxkLCBhcmdzKT0+e1xuICAgIGlmICh0eXBlb2Ygc3R5bGVGaWVsZCA9PT0gXCJvYmplY3RcIikgcmV0dXJuIHN0eWxlRmllbGQ7XG4gICAgaWYgKHR5cGVvZiBzdHlsZUZpZWxkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc3R5bGVGaWVsZChhcmdzKTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwib2JqZWN0XCIpIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiB7fTtcbn07XG5jb25zdCBjb250ZW50RmllbGRUb0NvbnRlbnQgPSAoY29udGVudEZpZWxkLCBhcmcpPT57XG4gICAgaWYgKCFjb250ZW50RmllbGQpIHJldHVybiBudWxsO1xuICAgIGlmICh0eXBlb2YgY29udGVudEZpZWxkICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBjb250ZW50RmllbGQ7XG4gICAgaWYgKHR5cGVvZiBjb250ZW50RmllbGQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBjb250ZW50RmllbGQoYXJnKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59O1xuXG5jb25zdCBzaWduYXR1cmVQcmVmaXggPSBcImhtYWMtc2hhMjU2PVwiO1xuY29uc3QgYWxnb3JpdGhtID0ge1xuICAgIG5hbWU6IFwiSE1BQ1wiLFxuICAgIGhhc2g6IFwiU0hBLTI1NlwiXG59O1xuY29uc3Qgc2lnblBheWxvYWQgPSBhc3luYyAocGF5bG9hZCwgc2VjcmV0KT0+e1xuICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICBjb25zdCBzaWduaW5nS2V5ID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXCJyYXdcIiwgZW5jb2Rlci5lbmNvZGUoc2VjcmV0KSwgYWxnb3JpdGhtLCBmYWxzZSwgW1xuICAgICAgICBcInNpZ25cIlxuICAgIF0pO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuc2lnbihhbGdvcml0aG0sIHNpZ25pbmdLZXksIGVuY29kZXIuZW5jb2RlKHBheWxvYWQpKS50aGVuKChzaWcpPT5CdWZmZXIuZnJvbShzaWcpLnRvU3RyaW5nKFwiaGV4XCIpKTtcbiAgICByZXR1cm4gYCR7c2lnbmF0dXJlUHJlZml4fSR7c2lnbmF0dXJlfWA7XG59O1xuY29uc3QgdmVyaWZ5U2lnbmF0dXJlID0gYXN5bmMgKHBheWxvYWQsIHNpZ25hdHVyZSwgc2VjcmV0KT0+e1xuICAgIGNvbnN0IHNpZyA9IHNpZ25hdHVyZT8uc2xpY2Uoc2lnbmF0dXJlUHJlZml4Lmxlbmd0aCk7XG4gICAgaWYgKCFzaWcpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgY29uc3Qgc2lnbmluZ0tleSA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFwicmF3XCIsIGVuY29kZXIuZW5jb2RlKHNlY3JldCksIGFsZ29yaXRobSwgZmFsc2UsIFtcbiAgICAgICAgXCJ2ZXJpZnlcIlxuICAgIF0pO1xuICAgIHJldHVybiBhd2FpdCBjcnlwdG8uc3VidGxlLnZlcmlmeShhbGdvcml0aG0sIHNpZ25pbmdLZXksIFVpbnQ4QXJyYXkuZnJvbShCdWZmZXIuZnJvbShzaWcsIFwiaGV4XCIpKSwgZW5jb2Rlci5lbmNvZGUocGF5bG9hZCkpO1xufTtcblxuZXhwb3J0IHsgQUNMU2NoZW1hLCBBTExPV0VEX0ZJTEVfVFlQRVMsIEJhZFJlcXVlc3RFcnJvciwgQ29udGVudERpc3Bvc2l0aW9uU2NoZW1hLCBGSUxFU0laRV9VTklUUywgRmV0Y2hDb250ZXh0LCBGZXRjaEVycm9yLCBJTlRFUk5BTF9ET19OT1RfVVNFX19mYXRhbENsaWVudEVycm9yLCBJTlRFUk5BTF9kb0Zvcm1hdHRpbmcsIEludmFsaWRGaWxlU2l6ZUVycm9yLCBJbnZhbGlkRmlsZVR5cGVFcnJvciwgSW52YWxpZFJvdXRlQ29uZmlnRXJyb3IsIEludmFsaWRVUkxFcnJvciwgUmV0cnlFcnJvciwgVW5rbm93bkZpbGVUeXBlRXJyb3IsIFVwbG9hZFRoaW5nRXJyb3IsIGFsbG93ZWRDb250ZW50VGV4dExhYmVsR2VuZXJhdG9yLCBhc0FycmF5LCBieXRlc1RvRmlsZVNpemUsIGNhcGl0YWxpemVTdGFydCwgY29udGVudERpc3Bvc2l0aW9uLCBjb250ZW50RmllbGRUb0NvbnRlbnQsIGV4cG9uZW50aWFsQmFja29mZiwgZmV0Y2hFZmYsIGZldGNoRWZmSnNvbiwgZmV0Y2hFZmZVbmtub3duLCBmaWxlU2l6ZVRvQnl0ZXMsIGZpbGxJbnB1dFJvdXRlQ29uZmlnLCBmaWx0ZXJPYmplY3RWYWx1ZXMsIGdlbmVyYXRlQ2xpZW50RHJvcHpvbmVBY2NlcHQsIGdlbmVyYXRlTWltZVR5cGVzLCBnZW5lcmF0ZVBlcm1pdHRlZEZpbGVUeXBlcywgZ2VuZXJhdGVVcGxvYWRUaGluZ1VSTCwgZ2V0RGVmYXVsdFNpemVGb3JUeXBlLCBnZXRFcnJvclR5cGVGcm9tU3RhdHVzQ29kZSwgZ2V0RmlsZXNGcm9tQ2xpcGJvYXJkRXZlbnQsIGdldEZ1bGxBcGlVcmwsIGdldFJlcXVlc3RVcmwsIGdldFN0YXR1c0NvZGVGcm9tRXJyb3IsIGdldFR5cGVGcm9tRmlsZU5hbWUsIGlzT2JqZWN0LCBpc1JvdXRlQXJyYXksIG9iamVjdEtleXMsIHBhcnNlUmVxdWVzdEpzb24sIHJlc29sdmVNYXliZVVybEFyZywgc2FmZVBhcnNlSlNPTiwgc2VtdmVyTGl0ZSwgc2lnblBheWxvYWQsIHN0eWxlRmllbGRUb0NsYXNzTmFtZSwgc3R5bGVGaWVsZFRvQ3NzT2JqZWN0LCB2ZXJpZnlTaWduYXR1cmUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@uploadthing+shared@6.7.3_@uploadthing+mime-types@0.2.9/node_modules/@uploadthing/shared/dist/index.js\n");

/***/ })

};
;