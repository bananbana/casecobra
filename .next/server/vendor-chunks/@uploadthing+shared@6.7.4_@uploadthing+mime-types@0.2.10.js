"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@uploadthing+shared@6.7.4_@uploadthing+mime-types@0.2.10";
exports.ids = ["vendor-chunks/@uploadthing+shared@6.7.4_@uploadthing+mime-types@0.2.10"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@uploadthing+shared@6.7.4_@uploadthing+mime-types@0.2.10/node_modules/@uploadthing/shared/dist/index.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@uploadthing+shared@6.7.4_@uploadthing+mime-types@0.2.10/node_modules/@uploadthing/shared/dist/index.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ALLOWED_FILE_TYPES: () => (/* binding */ ALLOWED_FILE_TYPES),\n/* harmony export */   BadRequestError: () => (/* binding */ BadRequestError),\n/* harmony export */   FILESIZE_UNITS: () => (/* binding */ FILESIZE_UNITS),\n/* harmony export */   FetchContext: () => (/* binding */ FetchContext),\n/* harmony export */   FetchError: () => (/* binding */ FetchError),\n/* harmony export */   INTERNAL_DO_NOT_USE__fatalClientError: () => (/* binding */ INTERNAL_DO_NOT_USE__fatalClientError),\n/* harmony export */   INTERNAL_doFormatting: () => (/* binding */ INTERNAL_doFormatting),\n/* harmony export */   InvalidFileSizeError: () => (/* binding */ InvalidFileSizeError),\n/* harmony export */   InvalidFileTypeError: () => (/* binding */ InvalidFileTypeError),\n/* harmony export */   InvalidJsonError: () => (/* binding */ InvalidJsonError),\n/* harmony export */   InvalidRouteConfigError: () => (/* binding */ InvalidRouteConfigError),\n/* harmony export */   InvalidURLError: () => (/* binding */ InvalidURLError),\n/* harmony export */   RetryError: () => (/* binding */ RetryError),\n/* harmony export */   UnknownFileTypeError: () => (/* binding */ UnknownFileTypeError),\n/* harmony export */   UploadThingError: () => (/* binding */ UploadThingError),\n/* harmony export */   ValidACLs: () => (/* binding */ ValidACLs),\n/* harmony export */   ValidContentDispositions: () => (/* binding */ ValidContentDispositions),\n/* harmony export */   allowedContentTextLabelGenerator: () => (/* binding */ allowedContentTextLabelGenerator),\n/* harmony export */   asArray: () => (/* binding */ asArray),\n/* harmony export */   bytesToFileSize: () => (/* binding */ bytesToFileSize),\n/* harmony export */   capitalizeStart: () => (/* binding */ capitalizeStart),\n/* harmony export */   contentDisposition: () => (/* binding */ contentDisposition),\n/* harmony export */   contentFieldToContent: () => (/* binding */ contentFieldToContent),\n/* harmony export */   exponentialBackoff: () => (/* binding */ exponentialBackoff),\n/* harmony export */   fetchEff: () => (/* binding */ fetchEff),\n/* harmony export */   fileSizeToBytes: () => (/* binding */ fileSizeToBytes),\n/* harmony export */   fillInputRouteConfig: () => (/* binding */ fillInputRouteConfig),\n/* harmony export */   filterObjectValues: () => (/* binding */ filterObjectValues),\n/* harmony export */   generateClientDropzoneAccept: () => (/* binding */ generateClientDropzoneAccept),\n/* harmony export */   generateMimeTypes: () => (/* binding */ generateMimeTypes),\n/* harmony export */   generatePermittedFileTypes: () => (/* binding */ generatePermittedFileTypes),\n/* harmony export */   generateUploadThingURL: () => (/* binding */ generateUploadThingURL),\n/* harmony export */   getDefaultSizeForType: () => (/* binding */ getDefaultSizeForType),\n/* harmony export */   getErrorTypeFromStatusCode: () => (/* binding */ getErrorTypeFromStatusCode),\n/* harmony export */   getFilesFromClipboardEvent: () => (/* binding */ getFilesFromClipboardEvent),\n/* harmony export */   getFullApiUrl: () => (/* binding */ getFullApiUrl),\n/* harmony export */   getRequestUrl: () => (/* binding */ getRequestUrl),\n/* harmony export */   getStatusCodeFromError: () => (/* binding */ getStatusCodeFromError),\n/* harmony export */   getTypeFromFileName: () => (/* binding */ getTypeFromFileName),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   isRouteArray: () => (/* binding */ isRouteArray),\n/* harmony export */   objectKeys: () => (/* binding */ objectKeys),\n/* harmony export */   parseRequestJson: () => (/* binding */ parseRequestJson),\n/* harmony export */   parseResponseJson: () => (/* binding */ parseResponseJson),\n/* harmony export */   resolveMaybeUrlArg: () => (/* binding */ resolveMaybeUrlArg),\n/* harmony export */   safeParseJSON: () => (/* binding */ safeParseJSON),\n/* harmony export */   semverLite: () => (/* binding */ semverLite),\n/* harmony export */   signPayload: () => (/* binding */ signPayload),\n/* harmony export */   styleFieldToClassName: () => (/* binding */ styleFieldToClassName),\n/* harmony export */   styleFieldToCssObject: () => (/* binding */ styleFieldToCssObject),\n/* harmony export */   verifySignature: () => (/* binding */ verifySignature)\n/* harmony export */ });\n/* harmony import */ var effect_Effect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! effect/Effect */ \"(ssr)/./node_modules/.pnpm/effect@3.1.5/node_modules/effect/dist/esm/Effect.js\");\n/* harmony import */ var std_env__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! std-env */ \"(ssr)/./node_modules/.pnpm/std-env@3.7.0/node_modules/std-env/dist/index.mjs\");\n/* harmony import */ var _uploadthing_mime_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @uploadthing/mime-types */ \"(ssr)/./node_modules/.pnpm/@uploadthing+mime-types@0.2.10/node_modules/@uploadthing/mime-types/dist/index.js\");\n/* harmony import */ var effect_Data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! effect/Data */ \"(ssr)/./node_modules/.pnpm/effect@3.1.5/node_modules/effect/dist/esm/Data.js\");\n/* harmony import */ var effect_Context__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! effect/Context */ \"(ssr)/./node_modules/.pnpm/effect@3.1.5/node_modules/effect/dist/esm/Context.js\");\n/* harmony import */ var effect_Duration__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! effect/Duration */ \"(ssr)/./node_modules/.pnpm/effect@3.1.5/node_modules/effect/dist/esm/Duration.js\");\n/* harmony import */ var effect_Function__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! effect/Function */ \"(ssr)/./node_modules/.pnpm/effect@3.1.5/node_modules/effect/dist/esm/Function.js\");\n/* harmony import */ var effect_Schedule__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! effect/Schedule */ \"(ssr)/./node_modules/.pnpm/effect@3.1.5/node_modules/effect/dist/esm/Schedule.js\");\n\n\n\n\n\n\n\n\n\nconst ValidContentDispositions = [\n    \"inline\",\n    \"attachment\"\n];\nconst ValidACLs = [\n    \"public-read\",\n    \"private\"\n];\n\nclass InvalidRouteConfigError extends (0,effect_Data__WEBPACK_IMPORTED_MODULE_0__.TaggedError)(\"InvalidRouteConfig\") {\n    constructor(type, field){\n        const reason = field ? `Expected route config to have a ${field} for key ${type} but none was found.` : `Encountered an invalid route config during backfilling. ${type} was not found.`;\n        super({\n            reason\n        });\n    }\n}\nclass UnknownFileTypeError extends (0,effect_Data__WEBPACK_IMPORTED_MODULE_0__.TaggedError)(\"UnknownFileType\") {\n    constructor(fileName){\n        const reason = `Could not determine type for ${fileName}`;\n        super({\n            reason\n        });\n    }\n}\nclass InvalidFileTypeError extends (0,effect_Data__WEBPACK_IMPORTED_MODULE_0__.TaggedError)(\"InvalidFileType\") {\n    constructor(fileType, fileName){\n        const reason = `File type ${fileType} not allowed for ${fileName}`;\n        super({\n            reason\n        });\n    }\n}\nclass InvalidFileSizeError extends (0,effect_Data__WEBPACK_IMPORTED_MODULE_0__.TaggedError)(\"InvalidFileSize\") {\n    constructor(fileSize){\n        const reason = `Invalid file size: ${fileSize}`;\n        super({\n            reason\n        });\n    }\n}\nclass InvalidURLError extends (0,effect_Data__WEBPACK_IMPORTED_MODULE_0__.TaggedError)(\"InvalidURL\") {\n    constructor(attemptedUrl){\n        super({\n            reason: `Failed to parse '${attemptedUrl}' as a URL.`\n        });\n    }\n}\nclass RetryError extends (0,effect_Data__WEBPACK_IMPORTED_MODULE_0__.TaggedError)(\"RetryError\") {\n}\n/**\n * @internal\n */ const getRequestUrl = (input)=>{\n    if (input instanceof Request) {\n        return input.url;\n    }\n    return input.toString();\n};\nclass FetchError extends (0,effect_Data__WEBPACK_IMPORTED_MODULE_0__.TaggedError)(\"FetchError\") {\n}\nclass InvalidJsonError extends (0,effect_Data__WEBPACK_IMPORTED_MODULE_0__.TaggedError)(\"InvalidJsonError\") {\n}\nclass BadRequestError extends (0,effect_Data__WEBPACK_IMPORTED_MODULE_0__.TaggedError)(\"BadRequestError\") {\n    getMessage() {\n        if (isObject(this.json)) {\n            if (typeof this.json.message === \"string\") return this.json.message;\n        }\n        return this.message;\n    }\n}\n\nfunction isRouteArray(routeConfig) {\n    return Array.isArray(routeConfig);\n}\nfunction getDefaultSizeForType(fileType) {\n    if (fileType === \"image\") return \"4MB\";\n    if (fileType === \"video\") return \"16MB\";\n    if (fileType === \"audio\") return \"8MB\";\n    if (fileType === \"blob\") return \"8MB\";\n    if (fileType === \"pdf\") return \"4MB\";\n    if (fileType === \"text\") return \"64KB\";\n    return \"4MB\";\n}\n/**\n * This function takes in the user's input and \"upscales\" it to a full config\n *\n * Example:\n * ```ts\n * [\"image\"] => { image: { maxFileSize: \"4MB\", limit: 1 } }\n * ```\n */ const fillInputRouteConfig = (routeConfig)=>{\n    // If array, apply defaults\n    if (isRouteArray(routeConfig)) {\n        return effect_Effect__WEBPACK_IMPORTED_MODULE_1__.succeed(routeConfig.reduce((acc, fileType)=>{\n            acc[fileType] = {\n                // Apply defaults\n                maxFileSize: getDefaultSizeForType(fileType),\n                maxFileCount: 1,\n                minFileCount: 1,\n                contentDisposition: \"inline\"\n            };\n            return acc;\n        }, {}));\n    }\n    // Backfill defaults onto config\n    const newConfig = {};\n    for (const key of objectKeys(routeConfig)){\n        const value = routeConfig[key];\n        if (!value) return effect_Effect__WEBPACK_IMPORTED_MODULE_1__.fail(new InvalidRouteConfigError(key));\n        const defaultValues = {\n            maxFileSize: getDefaultSizeForType(key),\n            maxFileCount: 1,\n            minFileCount: 1,\n            contentDisposition: \"inline\"\n        };\n        newConfig[key] = {\n            ...defaultValues,\n            ...value\n        };\n    }\n    return effect_Effect__WEBPACK_IMPORTED_MODULE_1__.succeed(newConfig);\n};\nconst getTypeFromFileName = (fileName, allowedTypes)=>{\n    const mimeType = (0,_uploadthing_mime_types__WEBPACK_IMPORTED_MODULE_2__.lookup)(fileName);\n    if (!mimeType) {\n        if (allowedTypes.includes(\"blob\")) return effect_Effect__WEBPACK_IMPORTED_MODULE_1__.succeed(\"blob\");\n        return effect_Effect__WEBPACK_IMPORTED_MODULE_1__.fail(new UnknownFileTypeError(fileName));\n    }\n    // If the user has specified a specific mime type, use that\n    if (allowedTypes.some((type)=>type.includes(\"/\"))) {\n        if (allowedTypes.includes(mimeType)) {\n            return effect_Effect__WEBPACK_IMPORTED_MODULE_1__.succeed(mimeType);\n        }\n    }\n    // Otherwise, we have a \"magic\" type eg. \"image\" or \"video\"\n    const type = mimeType.toLowerCase() === \"application/pdf\" ? \"pdf\" : mimeType.split(\"/\")[0];\n    if (!allowedTypes.includes(type)) {\n        // Blob is a catch-all for any file type not explicitly supported\n        if (allowedTypes.includes(\"blob\")) {\n            return effect_Effect__WEBPACK_IMPORTED_MODULE_1__.succeed(\"blob\");\n        } else {\n            return effect_Effect__WEBPACK_IMPORTED_MODULE_1__.fail(new InvalidFileTypeError(type, fileName));\n        }\n    }\n    return effect_Effect__WEBPACK_IMPORTED_MODULE_1__.succeed(type);\n};\nfunction generateUploadThingURL(path) {\n    let host = \"https://uploadthing.com\";\n    if (std_env__WEBPACK_IMPORTED_MODULE_3__.process.env.CUSTOM_INFRA_URL) {\n        host = std_env__WEBPACK_IMPORTED_MODULE_3__.process.env.CUSTOM_INFRA_URL;\n    }\n    return `${host}${path}`;\n}\nconst FILESIZE_UNITS = [\n    \"B\",\n    \"KB\",\n    \"MB\",\n    \"GB\"\n];\nconst fileSizeToBytes = (fileSize)=>{\n    const regex = new RegExp(`^(\\\\d+)(\\\\.\\\\d+)?\\\\s*(${FILESIZE_UNITS.join(\"|\")})$`, \"i\");\n    // make sure the string is in the format of 123KB\n    const match = fileSize.match(regex);\n    if (!match) {\n        return effect_Effect__WEBPACK_IMPORTED_MODULE_1__.fail(new InvalidFileSizeError(fileSize));\n    }\n    const sizeValue = parseFloat(match[1]);\n    const sizeUnit = match[3].toUpperCase();\n    const bytes = sizeValue * Math.pow(1024, FILESIZE_UNITS.indexOf(sizeUnit));\n    return effect_Effect__WEBPACK_IMPORTED_MODULE_1__.succeed(Math.floor(bytes));\n};\nconst bytesToFileSize = (bytes)=>{\n    if (bytes === 0 || bytes === -1) {\n        return \"0B\";\n    }\n    const i = Math.floor(Math.log(bytes) / Math.log(1000));\n    return `${(bytes / Math.pow(1000, i)).toFixed(2)}${FILESIZE_UNITS[i]}`;\n};\nasync function safeParseJSON(input) {\n    if (typeof input === \"string\") {\n        try {\n            return JSON.parse(input);\n        } catch (err) {\n            console.error(`Error parsing JSON, got '${input}'`);\n            return new Error(`Error parsing JSON, got '${input}'`);\n        }\n    }\n    const text = await input.text();\n    try {\n        return JSON.parse(text ?? \"null\");\n    } catch (err) {\n        console.error(`Error parsing JSON, got '${text}'`);\n        return new Error(`Error parsing JSON, got '${text}'`);\n    }\n}\n/** typesafe Object.keys */ function objectKeys(obj) {\n    return Object.keys(obj);\n}\n/** checks if obj is a valid, non-null object */ function isObject(obj) {\n    return typeof obj === \"object\" && obj !== null && !Array.isArray(obj);\n}\nfunction asArray(val) {\n    return Array.isArray(val) ? val : [\n        val\n    ];\n}\n/**\n * Filters an object's values based on a predicate\n * @example\n * filterObjectValues({ a: \"a\", b: null }, (v): v is string => v != null)\n * // ^? Record<string, string> { a: \"a\" }\n */ const filterObjectValues = (obj, predicate)=>{\n    return Object.fromEntries(Object.entries(obj).filter(([_, v])=>predicate(v)));\n};\n/** construct content-disposition header */ function contentDisposition(contentDisposition, fileName) {\n    return [\n        contentDisposition,\n        `filename=\"${encodeURI(fileName)}\"`,\n        `filename*=UTF-8''${encodeURI(fileName)}`\n    ].join(\"; \");\n}\nfunction semverLite(required, toCheck) {\n    // Pull out numbers from strings like `6.0.0`, `^6.4`, `~6.4.0`\n    const semverRegex = /(\\d+)\\.?(\\d+)?\\.?(\\d+)?/;\n    const requiredMatch = required.match(semverRegex);\n    if (!requiredMatch?.[0]) {\n        throw new Error(`Invalid semver requirement: ${required}`);\n    }\n    const toCheckMatch = toCheck.match(semverRegex);\n    if (!toCheckMatch?.[0]) {\n        throw new Error(`Invalid semver to check: ${toCheck}`);\n    }\n    const [_1, rMajor, rMinor, rPatch] = requiredMatch;\n    const [_2, cMajor, cMinor, cPatch] = toCheckMatch;\n    if (required.startsWith(\"^\")) {\n        // Major must be equal, minor must be greater or equal\n        if (rMajor !== cMajor) return false;\n        if (rMinor > cMinor) return false;\n        return true;\n    }\n    if (required.startsWith(\"~\")) {\n        // Major must be equal, minor must be equal\n        if (rMajor !== cMajor) return false;\n        if (rMinor !== cMinor) return false;\n        return true;\n    }\n    // Exact match\n    return rMajor === cMajor && rMinor === cMinor && rPatch === cPatch;\n}\nconst getFullApiUrl = (maybeUrl)=>effect_Effect__WEBPACK_IMPORTED_MODULE_1__.gen(function*() {\n        const base = (()=>{\n            if (typeof window !== \"undefined\") return window.location.origin;\n            if (std_env__WEBPACK_IMPORTED_MODULE_3__.process.env?.VERCEL_URL) return `https://${std_env__WEBPACK_IMPORTED_MODULE_3__.process.env.VERCEL_URL}`;\n            return \"http://localhost:3000\";\n        })();\n        const url = yield* effect_Effect__WEBPACK_IMPORTED_MODULE_1__[\"try\"]({\n            try: ()=>new URL(maybeUrl ?? \"/api/uploadthing\", base),\n            catch: ()=>new InvalidURLError(maybeUrl ?? \"/api/uploadthing\")\n        });\n        if (url.pathname === \"/\") {\n            url.pathname = \"/api/uploadthing\";\n        }\n        return url;\n    });\n/*\n * Returns a full URL to the dev's uploadthing endpoint\n * Can take either an origin, or a pathname, or a full URL\n * and will return the \"closest\" url matching the default\n * `<VERCEL_URL || localhost>/api/uploadthing`\n */ const resolveMaybeUrlArg = (maybeUrl)=>{\n    return maybeUrl instanceof URL ? maybeUrl : effect_Effect__WEBPACK_IMPORTED_MODULE_1__.runSync(getFullApiUrl(maybeUrl));\n};\n\nconst ALLOWED_FILE_TYPES = [\n    \"image\",\n    \"video\",\n    \"audio\",\n    \"pdf\",\n    \"text\",\n    \"blob\"\n];\n\nconst ERROR_CODES = {\n    // Generic\n    BAD_REQUEST: 400,\n    NOT_FOUND: 404,\n    FORBIDDEN: 403,\n    INTERNAL_SERVER_ERROR: 500,\n    INTERNAL_CLIENT_ERROR: 500,\n    // S3 specific\n    TOO_LARGE: 413,\n    TOO_SMALL: 400,\n    TOO_MANY_FILES: 400,\n    KEY_TOO_LONG: 400,\n    // UploadThing specific\n    URL_GENERATION_FAILED: 500,\n    UPLOAD_FAILED: 500,\n    MISSING_ENV: 500,\n    FILE_LIMIT_EXCEEDED: 500\n};\nfunction messageFromUnknown(cause, fallback) {\n    if (typeof cause === \"string\") {\n        return cause;\n    }\n    if (cause instanceof Error) {\n        return cause.message;\n    }\n    if (cause && typeof cause === \"object\" && \"message\" in cause && typeof cause.message === \"string\") {\n        return cause.message;\n    }\n    return fallback ?? \"An unknown error occurred\";\n}\nclass UploadThingError extends (0,effect_Data__WEBPACK_IMPORTED_MODULE_0__.TaggedError)(\"UploadThingError\") {\n    constructor(initOpts){\n        const opts = typeof initOpts === \"string\" ? {\n            code: \"INTERNAL_SERVER_ERROR\",\n            message: initOpts\n        } : initOpts;\n        const message = opts.message ?? messageFromUnknown(opts.cause, opts.code);\n        super({\n            message\n        });\n        this.code = opts.code;\n        this.data = opts.data;\n        if (opts.cause instanceof Error) {\n            this.cause = opts.cause;\n        } else if (isObject(opts.cause) && typeof opts.cause.status === \"number\" && typeof opts.cause.statusText === \"string\") {\n            this.cause = new Error(`Response ${opts.cause.status} ${opts.cause.statusText}`);\n        } else if (typeof opts.cause === \"string\") {\n            this.cause = new Error(opts.cause);\n        } else {\n            this.cause = opts.cause;\n        }\n    }\n    static toObject(error) {\n        return {\n            code: error.code,\n            message: error.message,\n            data: error.data\n        };\n    }\n    static serialize(error) {\n        return JSON.stringify(UploadThingError.toObject(error));\n    }\n}\nfunction getErrorTypeFromStatusCode(statusCode) {\n    for (const [code, status] of Object.entries(ERROR_CODES)){\n        if (status === statusCode) {\n            return code;\n        }\n    }\n    return \"INTERNAL_SERVER_ERROR\";\n}\nfunction getStatusCodeFromError(error) {\n    return ERROR_CODES[error.code] ?? 500;\n}\nconst INTERNAL_DO_NOT_USE__fatalClientError = (e)=>new UploadThingError({\n        code: \"INTERNAL_CLIENT_ERROR\",\n        message: \"Something went wrong. Please report this to UploadThing.\",\n        cause: e\n    });\n\nclass FetchContext extends effect_Context__WEBPACK_IMPORTED_MODULE_4__.Tag(\"uploadthing/FetchContext\")() {\n}\n// Temporary Effect wrappers below.\n// TODO should be refactored with much love\n// TODO handle error properly\nconst fetchEff = (input, init)=>effect_Effect__WEBPACK_IMPORTED_MODULE_1__.flatMap(FetchContext, ({ fetch, baseHeaders })=>{\n        const reqInfo = {\n            url: input.toString(),\n            method: init?.method,\n            body: init?.body,\n            headers: {\n                ...filterObjectValues(baseHeaders, (v)=>v != null),\n                ...init?.headers\n            }\n        };\n        return effect_Effect__WEBPACK_IMPORTED_MODULE_1__.tryPromise({\n            try: ()=>fetch(input, {\n                    ...init,\n                    headers: reqInfo.headers\n                }),\n            catch: (error)=>new FetchError({\n                    error,\n                    input: reqInfo\n                })\n        }).pipe(effect_Effect__WEBPACK_IMPORTED_MODULE_1__.map((res)=>Object.assign(res, {\n                requestUrl: reqInfo.url\n            })), effect_Effect__WEBPACK_IMPORTED_MODULE_1__.withSpan(\"fetch\", {\n            attributes: {\n                reqInfo\n            }\n        }));\n    });\nconst parseResponseJson = (res)=>effect_Effect__WEBPACK_IMPORTED_MODULE_1__.tryPromise({\n        try: async ()=>{\n            const json = await res.json();\n            return {\n                json,\n                ok: res.ok,\n                status: res.status\n            };\n        },\n        catch: (error)=>new InvalidJsonError({\n                error,\n                input: res.requestUrl\n            })\n    }).pipe(effect_Effect__WEBPACK_IMPORTED_MODULE_1__.filterOrFail(({ ok })=>ok, ({ json, status })=>new BadRequestError({\n            status,\n            message: `Request to ${res.requestUrl} failed with status ${status}`,\n            json\n        })), effect_Effect__WEBPACK_IMPORTED_MODULE_1__.map(({ json })=>json), effect_Effect__WEBPACK_IMPORTED_MODULE_1__.withSpan(\"parseJson\"));\nconst parseRequestJson = (req)=>effect_Effect__WEBPACK_IMPORTED_MODULE_1__.tryPromise({\n        try: ()=>req.json(),\n        catch: (error)=>new InvalidJsonError({\n                error,\n                input: req.url\n            })\n    }).pipe(effect_Effect__WEBPACK_IMPORTED_MODULE_1__.withSpan(\"parseRequestJson\"));\n/**\n * Schedule that retries with exponential backoff, up to 1 minute.\n * 10ms * 4^n, where n is the number of retries.\n */ const exponentialBackoff = (0,effect_Function__WEBPACK_IMPORTED_MODULE_5__.pipe)(effect_Schedule__WEBPACK_IMPORTED_MODULE_6__.exponential(effect_Duration__WEBPACK_IMPORTED_MODULE_7__.millis(10), 4), effect_Schedule__WEBPACK_IMPORTED_MODULE_6__.andThenEither(effect_Schedule__WEBPACK_IMPORTED_MODULE_6__.spaced(effect_Duration__WEBPACK_IMPORTED_MODULE_7__.seconds(1))), effect_Schedule__WEBPACK_IMPORTED_MODULE_6__.compose(effect_Schedule__WEBPACK_IMPORTED_MODULE_6__.elapsed), effect_Schedule__WEBPACK_IMPORTED_MODULE_6__.whileOutput(effect_Duration__WEBPACK_IMPORTED_MODULE_7__.lessThanOrEqualTo(effect_Duration__WEBPACK_IMPORTED_MODULE_7__.minutes(1))));\n\nconst generateMimeTypes = (fileTypes)=>{\n    const accepted = fileTypes.map((type)=>{\n        if (type === \"blob\") return \"blob\";\n        if (type === \"pdf\") return \"application/pdf\";\n        if (type.includes(\"/\")) return type;\n        else return `${type}/*`;\n    });\n    if (accepted.includes(\"blob\")) {\n        return [];\n    }\n    return accepted;\n};\nconst generateClientDropzoneAccept = (fileTypes)=>{\n    const mimeTypes = generateMimeTypes(fileTypes);\n    return Object.fromEntries(mimeTypes.map((type)=>[\n            type,\n            []\n        ]));\n};\nfunction getFilesFromClipboardEvent(event) {\n    const dataTransferItems = event.clipboardData?.items;\n    if (!dataTransferItems) return;\n    const files = Array.from(dataTransferItems).reduce((acc, curr)=>{\n        const f = curr.getAsFile();\n        return f ? [\n            ...acc,\n            f\n        ] : acc;\n    }, []);\n    return files;\n}\n/**\n * Shared helpers for our premade components that's reusable by multiple frameworks\n */ const generatePermittedFileTypes = (config)=>{\n    const fileTypes = config ? objectKeys(config) : [];\n    const maxFileCount = config ? Object.values(config).map((v)=>v.maxFileCount) : [];\n    return {\n        fileTypes,\n        multiple: maxFileCount.some((v)=>v && v > 1)\n    };\n};\nconst capitalizeStart = (str)=>{\n    return str.charAt(0).toUpperCase() + str.slice(1);\n};\nconst INTERNAL_doFormatting = (config)=>{\n    if (!config) return \"\";\n    const allowedTypes = objectKeys(config);\n    const formattedTypes = allowedTypes.map((f)=>f === \"blob\" ? \"file\" : f);\n    // Format multi-type uploader label as \"Supports videos, images and files\";\n    if (formattedTypes.length > 1) {\n        const lastType = formattedTypes.pop();\n        return `${formattedTypes.join(\"s, \")} and ${lastType}s`;\n    }\n    // Single type uploader label\n    const key = allowedTypes[0];\n    const formattedKey = formattedTypes[0];\n    const { maxFileSize, maxFileCount, minFileCount } = config[key];\n    if (maxFileCount && maxFileCount > 1) {\n        if (minFileCount > 1) {\n            return `${minFileCount} - ${maxFileCount} ${formattedKey}s up to ${maxFileSize}`;\n        } else {\n            return `${formattedKey}s up to ${maxFileSize}, max ${maxFileCount}`;\n        }\n    } else {\n        return `${formattedKey} (${maxFileSize})`;\n    }\n};\nconst allowedContentTextLabelGenerator = (config)=>{\n    return capitalizeStart(INTERNAL_doFormatting(config));\n};\nconst styleFieldToClassName = (styleField, args)=>{\n    if (typeof styleField === \"string\") return styleField;\n    if (typeof styleField === \"function\") {\n        const result = styleField(args);\n        if (typeof result === \"string\") return result;\n    }\n    return \"\";\n};\nconst styleFieldToCssObject = (styleField, args)=>{\n    if (typeof styleField === \"object\") return styleField;\n    if (typeof styleField === \"function\") {\n        const result = styleField(args);\n        if (typeof result === \"object\") return result;\n    }\n    return {};\n};\nconst contentFieldToContent = (contentField, arg)=>{\n    if (!contentField) return null;\n    if (typeof contentField !== \"function\") return contentField;\n    if (typeof contentField === \"function\") {\n        const result = contentField(arg);\n        return result;\n    }\n};\n\nconst signaturePrefix = \"hmac-sha256=\";\nconst algorithm = {\n    name: \"HMAC\",\n    hash: \"SHA-256\"\n};\nconst signPayload = async (payload, secret)=>{\n    const encoder = new TextEncoder();\n    const signingKey = await crypto.subtle.importKey(\"raw\", encoder.encode(secret), algorithm, false, [\n        \"sign\"\n    ]);\n    const signature = await crypto.subtle.sign(algorithm, signingKey, encoder.encode(payload)).then((sig)=>Buffer.from(sig).toString(\"hex\"));\n    return `${signaturePrefix}${signature}`;\n};\nconst verifySignature = async (payload, signature, secret)=>{\n    const sig = signature?.slice(signaturePrefix.length);\n    if (!sig) return false;\n    const encoder = new TextEncoder();\n    const signingKey = await crypto.subtle.importKey(\"raw\", encoder.encode(secret), algorithm, false, [\n        \"verify\"\n    ]);\n    return await crypto.subtle.verify(algorithm, signingKey, Uint8Array.from(Buffer.from(sig, \"hex\")), encoder.encode(payload));\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHVwbG9hZHRoaW5nK3NoYXJlZEA2LjcuNF9AdXBsb2FkdGhpbmcrbWltZS10eXBlc0AwLjIuMTAvbm9kZV9tb2R1bGVzL0B1cGxvYWR0aGluZy9zaGFyZWQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3QztBQUNOO0FBQ2U7QUFDUDtBQUNBO0FBQ0U7QUFDTDtBQUNLOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyx3REFBVztBQUNqRDtBQUNBLGtFQUFrRSxPQUFPLFVBQVUsTUFBTSxrRkFBa0YsTUFBTTtBQUNqTDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQ0FBbUMsd0RBQVc7QUFDOUM7QUFDQSx1REFBdUQsU0FBUztBQUNoRTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQ0FBbUMsd0RBQVc7QUFDOUM7QUFDQSxvQ0FBb0MsVUFBVSxrQkFBa0IsU0FBUztBQUN6RTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQ0FBbUMsd0RBQVc7QUFDOUM7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw4QkFBOEIsd0RBQVc7QUFDekM7QUFDQTtBQUNBLHdDQUF3QyxhQUFhO0FBQ3JELFNBQVM7QUFDVDtBQUNBO0FBQ0EseUJBQXlCLHdEQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix3REFBVztBQUNwQztBQUNBLCtCQUErQix3REFBVztBQUMxQztBQUNBLDhCQUE4Qix3REFBVztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Qjs7QUFFcFA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixLQUFLO0FBQzVCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNEJBQTRCLE1BQU0sU0FBUztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMENBQTBDO0FBQ3REO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYyxJQUFJLGNBQWMsRUFBRSxhQUFhLFVBQVUsWUFBWTtBQUMzRixVQUFVO0FBQ1Ysc0JBQXNCLGFBQWEsVUFBVSxZQUFZLFFBQVEsYUFBYTtBQUM5RTtBQUNBLE1BQU07QUFDTixrQkFBa0IsY0FBYyxHQUFHLFlBQVk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0IsRUFBRSxVQUFVO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU0K0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXNlY29icmEvLi9ub2RlX21vZHVsZXMvLnBucG0vQHVwbG9hZHRoaW5nK3NoYXJlZEA2LjcuNF9AdXBsb2FkdGhpbmcrbWltZS10eXBlc0AwLjIuMTAvbm9kZV9tb2R1bGVzL0B1cGxvYWR0aGluZy9zaGFyZWQvZGlzdC9pbmRleC5qcz9iZjQzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEVmZmVjdCBmcm9tICdlZmZlY3QvRWZmZWN0JztcbmltcG9ydCB7IHByb2Nlc3MgfSBmcm9tICdzdGQtZW52JztcbmltcG9ydCB7IGxvb2t1cCB9IGZyb20gJ0B1cGxvYWR0aGluZy9taW1lLXR5cGVzJztcbmltcG9ydCB7IFRhZ2dlZEVycm9yIH0gZnJvbSAnZWZmZWN0L0RhdGEnO1xuaW1wb3J0ICogYXMgQ29udGV4dCBmcm9tICdlZmZlY3QvQ29udGV4dCc7XG5pbXBvcnQgKiBhcyBEdXJhdGlvbiBmcm9tICdlZmZlY3QvRHVyYXRpb24nO1xuaW1wb3J0IHsgcGlwZSB9IGZyb20gJ2VmZmVjdC9GdW5jdGlvbic7XG5pbXBvcnQgKiBhcyBTY2hlZHVsZSBmcm9tICdlZmZlY3QvU2NoZWR1bGUnO1xuXG5jb25zdCBWYWxpZENvbnRlbnREaXNwb3NpdGlvbnMgPSBbXG4gICAgXCJpbmxpbmVcIixcbiAgICBcImF0dGFjaG1lbnRcIlxuXTtcbmNvbnN0IFZhbGlkQUNMcyA9IFtcbiAgICBcInB1YmxpYy1yZWFkXCIsXG4gICAgXCJwcml2YXRlXCJcbl07XG5cbmNsYXNzIEludmFsaWRSb3V0ZUNvbmZpZ0Vycm9yIGV4dGVuZHMgVGFnZ2VkRXJyb3IoXCJJbnZhbGlkUm91dGVDb25maWdcIikge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGZpZWxkKXtcbiAgICAgICAgY29uc3QgcmVhc29uID0gZmllbGQgPyBgRXhwZWN0ZWQgcm91dGUgY29uZmlnIHRvIGhhdmUgYSAke2ZpZWxkfSBmb3Iga2V5ICR7dHlwZX0gYnV0IG5vbmUgd2FzIGZvdW5kLmAgOiBgRW5jb3VudGVyZWQgYW4gaW52YWxpZCByb3V0ZSBjb25maWcgZHVyaW5nIGJhY2tmaWxsaW5nLiAke3R5cGV9IHdhcyBub3QgZm91bmQuYDtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgcmVhc29uXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFVua25vd25GaWxlVHlwZUVycm9yIGV4dGVuZHMgVGFnZ2VkRXJyb3IoXCJVbmtub3duRmlsZVR5cGVcIikge1xuICAgIGNvbnN0cnVjdG9yKGZpbGVOYW1lKXtcbiAgICAgICAgY29uc3QgcmVhc29uID0gYENvdWxkIG5vdCBkZXRlcm1pbmUgdHlwZSBmb3IgJHtmaWxlTmFtZX1gO1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICByZWFzb25cbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgSW52YWxpZEZpbGVUeXBlRXJyb3IgZXh0ZW5kcyBUYWdnZWRFcnJvcihcIkludmFsaWRGaWxlVHlwZVwiKSB7XG4gICAgY29uc3RydWN0b3IoZmlsZVR5cGUsIGZpbGVOYW1lKXtcbiAgICAgICAgY29uc3QgcmVhc29uID0gYEZpbGUgdHlwZSAke2ZpbGVUeXBlfSBub3QgYWxsb3dlZCBmb3IgJHtmaWxlTmFtZX1gO1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICByZWFzb25cbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgSW52YWxpZEZpbGVTaXplRXJyb3IgZXh0ZW5kcyBUYWdnZWRFcnJvcihcIkludmFsaWRGaWxlU2l6ZVwiKSB7XG4gICAgY29uc3RydWN0b3IoZmlsZVNpemUpe1xuICAgICAgICBjb25zdCByZWFzb24gPSBgSW52YWxpZCBmaWxlIHNpemU6ICR7ZmlsZVNpemV9YDtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgcmVhc29uXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIEludmFsaWRVUkxFcnJvciBleHRlbmRzIFRhZ2dlZEVycm9yKFwiSW52YWxpZFVSTFwiKSB7XG4gICAgY29uc3RydWN0b3IoYXR0ZW1wdGVkVXJsKXtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgcmVhc29uOiBgRmFpbGVkIHRvIHBhcnNlICcke2F0dGVtcHRlZFVybH0nIGFzIGEgVVJMLmBcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgUmV0cnlFcnJvciBleHRlbmRzIFRhZ2dlZEVycm9yKFwiUmV0cnlFcnJvclwiKSB7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovIGNvbnN0IGdldFJlcXVlc3RVcmwgPSAoaW5wdXQpPT57XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgICAgICByZXR1cm4gaW5wdXQudXJsO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXQudG9TdHJpbmcoKTtcbn07XG5jbGFzcyBGZXRjaEVycm9yIGV4dGVuZHMgVGFnZ2VkRXJyb3IoXCJGZXRjaEVycm9yXCIpIHtcbn1cbmNsYXNzIEludmFsaWRKc29uRXJyb3IgZXh0ZW5kcyBUYWdnZWRFcnJvcihcIkludmFsaWRKc29uRXJyb3JcIikge1xufVxuY2xhc3MgQmFkUmVxdWVzdEVycm9yIGV4dGVuZHMgVGFnZ2VkRXJyb3IoXCJCYWRSZXF1ZXN0RXJyb3JcIikge1xuICAgIGdldE1lc3NhZ2UoKSB7XG4gICAgICAgIGlmIChpc09iamVjdCh0aGlzLmpzb24pKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuanNvbi5tZXNzYWdlID09PSBcInN0cmluZ1wiKSByZXR1cm4gdGhpcy5qc29uLm1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzUm91dGVBcnJheShyb3V0ZUNvbmZpZykge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHJvdXRlQ29uZmlnKTtcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRTaXplRm9yVHlwZShmaWxlVHlwZSkge1xuICAgIGlmIChmaWxlVHlwZSA9PT0gXCJpbWFnZVwiKSByZXR1cm4gXCI0TUJcIjtcbiAgICBpZiAoZmlsZVR5cGUgPT09IFwidmlkZW9cIikgcmV0dXJuIFwiMTZNQlwiO1xuICAgIGlmIChmaWxlVHlwZSA9PT0gXCJhdWRpb1wiKSByZXR1cm4gXCI4TUJcIjtcbiAgICBpZiAoZmlsZVR5cGUgPT09IFwiYmxvYlwiKSByZXR1cm4gXCI4TUJcIjtcbiAgICBpZiAoZmlsZVR5cGUgPT09IFwicGRmXCIpIHJldHVybiBcIjRNQlwiO1xuICAgIGlmIChmaWxlVHlwZSA9PT0gXCJ0ZXh0XCIpIHJldHVybiBcIjY0S0JcIjtcbiAgICByZXR1cm4gXCI0TUJcIjtcbn1cbi8qKlxuICogVGhpcyBmdW5jdGlvbiB0YWtlcyBpbiB0aGUgdXNlcidzIGlucHV0IGFuZCBcInVwc2NhbGVzXCIgaXQgdG8gYSBmdWxsIGNvbmZpZ1xuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGB0c1xuICogW1wiaW1hZ2VcIl0gPT4geyBpbWFnZTogeyBtYXhGaWxlU2l6ZTogXCI0TUJcIiwgbGltaXQ6IDEgfSB9XG4gKiBgYGBcbiAqLyBjb25zdCBmaWxsSW5wdXRSb3V0ZUNvbmZpZyA9IChyb3V0ZUNvbmZpZyk9PntcbiAgICAvLyBJZiBhcnJheSwgYXBwbHkgZGVmYXVsdHNcbiAgICBpZiAoaXNSb3V0ZUFycmF5KHJvdXRlQ29uZmlnKSkge1xuICAgICAgICByZXR1cm4gRWZmZWN0LnN1Y2NlZWQocm91dGVDb25maWcucmVkdWNlKChhY2MsIGZpbGVUeXBlKT0+e1xuICAgICAgICAgICAgYWNjW2ZpbGVUeXBlXSA9IHtcbiAgICAgICAgICAgICAgICAvLyBBcHBseSBkZWZhdWx0c1xuICAgICAgICAgICAgICAgIG1heEZpbGVTaXplOiBnZXREZWZhdWx0U2l6ZUZvclR5cGUoZmlsZVR5cGUpLFxuICAgICAgICAgICAgICAgIG1heEZpbGVDb3VudDogMSxcbiAgICAgICAgICAgICAgICBtaW5GaWxlQ291bnQ6IDEsXG4gICAgICAgICAgICAgICAgY29udGVudERpc3Bvc2l0aW9uOiBcImlubGluZVwiXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pKTtcbiAgICB9XG4gICAgLy8gQmFja2ZpbGwgZGVmYXVsdHMgb250byBjb25maWdcbiAgICBjb25zdCBuZXdDb25maWcgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBvYmplY3RLZXlzKHJvdXRlQ29uZmlnKSl7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcm91dGVDb25maWdba2V5XTtcbiAgICAgICAgaWYgKCF2YWx1ZSkgcmV0dXJuIEVmZmVjdC5mYWlsKG5ldyBJbnZhbGlkUm91dGVDb25maWdFcnJvcihrZXkpKTtcbiAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlcyA9IHtcbiAgICAgICAgICAgIG1heEZpbGVTaXplOiBnZXREZWZhdWx0U2l6ZUZvclR5cGUoa2V5KSxcbiAgICAgICAgICAgIG1heEZpbGVDb3VudDogMSxcbiAgICAgICAgICAgIG1pbkZpbGVDb3VudDogMSxcbiAgICAgICAgICAgIGNvbnRlbnREaXNwb3NpdGlvbjogXCJpbmxpbmVcIlxuICAgICAgICB9O1xuICAgICAgICBuZXdDb25maWdba2V5XSA9IHtcbiAgICAgICAgICAgIC4uLmRlZmF1bHRWYWx1ZXMsXG4gICAgICAgICAgICAuLi52YWx1ZVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gRWZmZWN0LnN1Y2NlZWQobmV3Q29uZmlnKTtcbn07XG5jb25zdCBnZXRUeXBlRnJvbUZpbGVOYW1lID0gKGZpbGVOYW1lLCBhbGxvd2VkVHlwZXMpPT57XG4gICAgY29uc3QgbWltZVR5cGUgPSBsb29rdXAoZmlsZU5hbWUpO1xuICAgIGlmICghbWltZVR5cGUpIHtcbiAgICAgICAgaWYgKGFsbG93ZWRUeXBlcy5pbmNsdWRlcyhcImJsb2JcIikpIHJldHVybiBFZmZlY3Quc3VjY2VlZChcImJsb2JcIik7XG4gICAgICAgIHJldHVybiBFZmZlY3QuZmFpbChuZXcgVW5rbm93bkZpbGVUeXBlRXJyb3IoZmlsZU5hbWUpKTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIHVzZXIgaGFzIHNwZWNpZmllZCBhIHNwZWNpZmljIG1pbWUgdHlwZSwgdXNlIHRoYXRcbiAgICBpZiAoYWxsb3dlZFR5cGVzLnNvbWUoKHR5cGUpPT50eXBlLmluY2x1ZGVzKFwiL1wiKSkpIHtcbiAgICAgICAgaWYgKGFsbG93ZWRUeXBlcy5pbmNsdWRlcyhtaW1lVHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBFZmZlY3Quc3VjY2VlZChtaW1lVHlwZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gT3RoZXJ3aXNlLCB3ZSBoYXZlIGEgXCJtYWdpY1wiIHR5cGUgZWcuIFwiaW1hZ2VcIiBvciBcInZpZGVvXCJcbiAgICBjb25zdCB0eXBlID0gbWltZVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gXCJhcHBsaWNhdGlvbi9wZGZcIiA/IFwicGRmXCIgOiBtaW1lVHlwZS5zcGxpdChcIi9cIilbMF07XG4gICAgaWYgKCFhbGxvd2VkVHlwZXMuaW5jbHVkZXModHlwZSkpIHtcbiAgICAgICAgLy8gQmxvYiBpcyBhIGNhdGNoLWFsbCBmb3IgYW55IGZpbGUgdHlwZSBub3QgZXhwbGljaXRseSBzdXBwb3J0ZWRcbiAgICAgICAgaWYgKGFsbG93ZWRUeXBlcy5pbmNsdWRlcyhcImJsb2JcIikpIHtcbiAgICAgICAgICAgIHJldHVybiBFZmZlY3Quc3VjY2VlZChcImJsb2JcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gRWZmZWN0LmZhaWwobmV3IEludmFsaWRGaWxlVHlwZUVycm9yKHR5cGUsIGZpbGVOYW1lKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEVmZmVjdC5zdWNjZWVkKHR5cGUpO1xufTtcbmZ1bmN0aW9uIGdlbmVyYXRlVXBsb2FkVGhpbmdVUkwocGF0aCkge1xuICAgIGxldCBob3N0ID0gXCJodHRwczovL3VwbG9hZHRoaW5nLmNvbVwiO1xuICAgIGlmIChwcm9jZXNzLmVudi5DVVNUT01fSU5GUkFfVVJMKSB7XG4gICAgICAgIGhvc3QgPSBwcm9jZXNzLmVudi5DVVNUT01fSU5GUkFfVVJMO1xuICAgIH1cbiAgICByZXR1cm4gYCR7aG9zdH0ke3BhdGh9YDtcbn1cbmNvbnN0IEZJTEVTSVpFX1VOSVRTID0gW1xuICAgIFwiQlwiLFxuICAgIFwiS0JcIixcbiAgICBcIk1CXCIsXG4gICAgXCJHQlwiXG5dO1xuY29uc3QgZmlsZVNpemVUb0J5dGVzID0gKGZpbGVTaXplKT0+e1xuICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgXihcXFxcZCspKFxcXFwuXFxcXGQrKT9cXFxccyooJHtGSUxFU0laRV9VTklUUy5qb2luKFwifFwiKX0pJGAsIFwiaVwiKTtcbiAgICAvLyBtYWtlIHN1cmUgdGhlIHN0cmluZyBpcyBpbiB0aGUgZm9ybWF0IG9mIDEyM0tCXG4gICAgY29uc3QgbWF0Y2ggPSBmaWxlU2l6ZS5tYXRjaChyZWdleCk7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgICByZXR1cm4gRWZmZWN0LmZhaWwobmV3IEludmFsaWRGaWxlU2l6ZUVycm9yKGZpbGVTaXplKSk7XG4gICAgfVxuICAgIGNvbnN0IHNpemVWYWx1ZSA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICAgIGNvbnN0IHNpemVVbml0ID0gbWF0Y2hbM10udG9VcHBlckNhc2UoKTtcbiAgICBjb25zdCBieXRlcyA9IHNpemVWYWx1ZSAqIE1hdGgucG93KDEwMjQsIEZJTEVTSVpFX1VOSVRTLmluZGV4T2Yoc2l6ZVVuaXQpKTtcbiAgICByZXR1cm4gRWZmZWN0LnN1Y2NlZWQoTWF0aC5mbG9vcihieXRlcykpO1xufTtcbmNvbnN0IGJ5dGVzVG9GaWxlU2l6ZSA9IChieXRlcyk9PntcbiAgICBpZiAoYnl0ZXMgPT09IDAgfHwgYnl0ZXMgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBcIjBCXCI7XG4gICAgfVxuICAgIGNvbnN0IGkgPSBNYXRoLmZsb29yKE1hdGgubG9nKGJ5dGVzKSAvIE1hdGgubG9nKDEwMDApKTtcbiAgICByZXR1cm4gYCR7KGJ5dGVzIC8gTWF0aC5wb3coMTAwMCwgaSkpLnRvRml4ZWQoMil9JHtGSUxFU0laRV9VTklUU1tpXX1gO1xufTtcbmFzeW5jIGZ1bmN0aW9uIHNhZmVQYXJzZUpTT04oaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShpbnB1dCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcGFyc2luZyBKU09OLCBnb3QgJyR7aW5wdXR9J2ApO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgRXJyb3IgcGFyc2luZyBKU09OLCBnb3QgJyR7aW5wdXR9J2ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRleHQgPSBhd2FpdCBpbnB1dC50ZXh0KCk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGV4dCA/PyBcIm51bGxcIik7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHBhcnNpbmcgSlNPTiwgZ290ICcke3RleHR9J2ApO1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKGBFcnJvciBwYXJzaW5nIEpTT04sIGdvdCAnJHt0ZXh0fSdgKTtcbiAgICB9XG59XG4vKiogdHlwZXNhZmUgT2JqZWN0LmtleXMgKi8gZnVuY3Rpb24gb2JqZWN0S2V5cyhvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKTtcbn1cbi8qKiBjaGVja3MgaWYgb2JqIGlzIGEgdmFsaWQsIG5vbi1udWxsIG9iamVjdCAqLyBmdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiBvYmogIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkob2JqKTtcbn1cbmZ1bmN0aW9uIGFzQXJyYXkodmFsKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsKSA/IHZhbCA6IFtcbiAgICAgICAgdmFsXG4gICAgXTtcbn1cbi8qKlxuICogRmlsdGVycyBhbiBvYmplY3QncyB2YWx1ZXMgYmFzZWQgb24gYSBwcmVkaWNhdGVcbiAqIEBleGFtcGxlXG4gKiBmaWx0ZXJPYmplY3RWYWx1ZXMoeyBhOiBcImFcIiwgYjogbnVsbCB9LCAodik6IHYgaXMgc3RyaW5nID0+IHYgIT0gbnVsbClcbiAqIC8vIF4/IFJlY29yZDxzdHJpbmcsIHN0cmluZz4geyBhOiBcImFcIiB9XG4gKi8gY29uc3QgZmlsdGVyT2JqZWN0VmFsdWVzID0gKG9iaiwgcHJlZGljYXRlKT0+e1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMob2JqKS5maWx0ZXIoKFtfLCB2XSk9PnByZWRpY2F0ZSh2KSkpO1xufTtcbi8qKiBjb25zdHJ1Y3QgY29udGVudC1kaXNwb3NpdGlvbiBoZWFkZXIgKi8gZnVuY3Rpb24gY29udGVudERpc3Bvc2l0aW9uKGNvbnRlbnREaXNwb3NpdGlvbiwgZmlsZU5hbWUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBjb250ZW50RGlzcG9zaXRpb24sXG4gICAgICAgIGBmaWxlbmFtZT1cIiR7ZW5jb2RlVVJJKGZpbGVOYW1lKX1cImAsXG4gICAgICAgIGBmaWxlbmFtZSo9VVRGLTgnJyR7ZW5jb2RlVVJJKGZpbGVOYW1lKX1gXG4gICAgXS5qb2luKFwiOyBcIik7XG59XG5mdW5jdGlvbiBzZW12ZXJMaXRlKHJlcXVpcmVkLCB0b0NoZWNrKSB7XG4gICAgLy8gUHVsbCBvdXQgbnVtYmVycyBmcm9tIHN0cmluZ3MgbGlrZSBgNi4wLjBgLCBgXjYuNGAsIGB+Ni40LjBgXG4gICAgY29uc3Qgc2VtdmVyUmVnZXggPSAvKFxcZCspXFwuPyhcXGQrKT9cXC4/KFxcZCspPy87XG4gICAgY29uc3QgcmVxdWlyZWRNYXRjaCA9IHJlcXVpcmVkLm1hdGNoKHNlbXZlclJlZ2V4KTtcbiAgICBpZiAoIXJlcXVpcmVkTWF0Y2g/LlswXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2VtdmVyIHJlcXVpcmVtZW50OiAke3JlcXVpcmVkfWApO1xuICAgIH1cbiAgICBjb25zdCB0b0NoZWNrTWF0Y2ggPSB0b0NoZWNrLm1hdGNoKHNlbXZlclJlZ2V4KTtcbiAgICBpZiAoIXRvQ2hlY2tNYXRjaD8uWzBdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzZW12ZXIgdG8gY2hlY2s6ICR7dG9DaGVja31gKTtcbiAgICB9XG4gICAgY29uc3QgW18xLCByTWFqb3IsIHJNaW5vciwgclBhdGNoXSA9IHJlcXVpcmVkTWF0Y2g7XG4gICAgY29uc3QgW18yLCBjTWFqb3IsIGNNaW5vciwgY1BhdGNoXSA9IHRvQ2hlY2tNYXRjaDtcbiAgICBpZiAocmVxdWlyZWQuc3RhcnRzV2l0aChcIl5cIikpIHtcbiAgICAgICAgLy8gTWFqb3IgbXVzdCBiZSBlcXVhbCwgbWlub3IgbXVzdCBiZSBncmVhdGVyIG9yIGVxdWFsXG4gICAgICAgIGlmIChyTWFqb3IgIT09IGNNYWpvcikgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAock1pbm9yID4gY01pbm9yKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAocmVxdWlyZWQuc3RhcnRzV2l0aChcIn5cIikpIHtcbiAgICAgICAgLy8gTWFqb3IgbXVzdCBiZSBlcXVhbCwgbWlub3IgbXVzdCBiZSBlcXVhbFxuICAgICAgICBpZiAock1ham9yICE9PSBjTWFqb3IpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHJNaW5vciAhPT0gY01pbm9yKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBFeGFjdCBtYXRjaFxuICAgIHJldHVybiByTWFqb3IgPT09IGNNYWpvciAmJiByTWlub3IgPT09IGNNaW5vciAmJiByUGF0Y2ggPT09IGNQYXRjaDtcbn1cbmNvbnN0IGdldEZ1bGxBcGlVcmwgPSAobWF5YmVVcmwpPT5FZmZlY3QuZ2VuKGZ1bmN0aW9uKigpIHtcbiAgICAgICAgY29uc3QgYmFzZSA9ICgoKT0+e1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiB3aW5kb3cubG9jYXRpb24ub3JpZ2luO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Py5WRVJDRUxfVVJMKSByZXR1cm4gYGh0dHBzOi8vJHtwcm9jZXNzLmVudi5WRVJDRUxfVVJMfWA7XG4gICAgICAgICAgICByZXR1cm4gXCJodHRwOi8vbG9jYWxob3N0OjMwMDBcIjtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgY29uc3QgdXJsID0geWllbGQqIEVmZmVjdC50cnkoe1xuICAgICAgICAgICAgdHJ5OiAoKT0+bmV3IFVSTChtYXliZVVybCA/PyBcIi9hcGkvdXBsb2FkdGhpbmdcIiwgYmFzZSksXG4gICAgICAgICAgICBjYXRjaDogKCk9Pm5ldyBJbnZhbGlkVVJMRXJyb3IobWF5YmVVcmwgPz8gXCIvYXBpL3VwbG9hZHRoaW5nXCIpXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodXJsLnBhdGhuYW1lID09PSBcIi9cIikge1xuICAgICAgICAgICAgdXJsLnBhdGhuYW1lID0gXCIvYXBpL3VwbG9hZHRoaW5nXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9KTtcbi8qXG4gKiBSZXR1cm5zIGEgZnVsbCBVUkwgdG8gdGhlIGRldidzIHVwbG9hZHRoaW5nIGVuZHBvaW50XG4gKiBDYW4gdGFrZSBlaXRoZXIgYW4gb3JpZ2luLCBvciBhIHBhdGhuYW1lLCBvciBhIGZ1bGwgVVJMXG4gKiBhbmQgd2lsbCByZXR1cm4gdGhlIFwiY2xvc2VzdFwiIHVybCBtYXRjaGluZyB0aGUgZGVmYXVsdFxuICogYDxWRVJDRUxfVVJMIHx8IGxvY2FsaG9zdD4vYXBpL3VwbG9hZHRoaW5nYFxuICovIGNvbnN0IHJlc29sdmVNYXliZVVybEFyZyA9IChtYXliZVVybCk9PntcbiAgICByZXR1cm4gbWF5YmVVcmwgaW5zdGFuY2VvZiBVUkwgPyBtYXliZVVybCA6IEVmZmVjdC5ydW5TeW5jKGdldEZ1bGxBcGlVcmwobWF5YmVVcmwpKTtcbn07XG5cbmNvbnN0IEFMTE9XRURfRklMRV9UWVBFUyA9IFtcbiAgICBcImltYWdlXCIsXG4gICAgXCJ2aWRlb1wiLFxuICAgIFwiYXVkaW9cIixcbiAgICBcInBkZlwiLFxuICAgIFwidGV4dFwiLFxuICAgIFwiYmxvYlwiXG5dO1xuXG5jb25zdCBFUlJPUl9DT0RFUyA9IHtcbiAgICAvLyBHZW5lcmljXG4gICAgQkFEX1JFUVVFU1Q6IDQwMCxcbiAgICBOT1RfRk9VTkQ6IDQwNCxcbiAgICBGT1JCSURERU46IDQwMyxcbiAgICBJTlRFUk5BTF9TRVJWRVJfRVJST1I6IDUwMCxcbiAgICBJTlRFUk5BTF9DTElFTlRfRVJST1I6IDUwMCxcbiAgICAvLyBTMyBzcGVjaWZpY1xuICAgIFRPT19MQVJHRTogNDEzLFxuICAgIFRPT19TTUFMTDogNDAwLFxuICAgIFRPT19NQU5ZX0ZJTEVTOiA0MDAsXG4gICAgS0VZX1RPT19MT05HOiA0MDAsXG4gICAgLy8gVXBsb2FkVGhpbmcgc3BlY2lmaWNcbiAgICBVUkxfR0VORVJBVElPTl9GQUlMRUQ6IDUwMCxcbiAgICBVUExPQURfRkFJTEVEOiA1MDAsXG4gICAgTUlTU0lOR19FTlY6IDUwMCxcbiAgICBGSUxFX0xJTUlUX0VYQ0VFREVEOiA1MDBcbn07XG5mdW5jdGlvbiBtZXNzYWdlRnJvbVVua25vd24oY2F1c2UsIGZhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjYXVzZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gY2F1c2U7XG4gICAgfVxuICAgIGlmIChjYXVzZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHJldHVybiBjYXVzZS5tZXNzYWdlO1xuICAgIH1cbiAgICBpZiAoY2F1c2UgJiYgdHlwZW9mIGNhdXNlID09PSBcIm9iamVjdFwiICYmIFwibWVzc2FnZVwiIGluIGNhdXNlICYmIHR5cGVvZiBjYXVzZS5tZXNzYWdlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBjYXVzZS5tZXNzYWdlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsbGJhY2sgPz8gXCJBbiB1bmtub3duIGVycm9yIG9jY3VycmVkXCI7XG59XG5jbGFzcyBVcGxvYWRUaGluZ0Vycm9yIGV4dGVuZHMgVGFnZ2VkRXJyb3IoXCJVcGxvYWRUaGluZ0Vycm9yXCIpIHtcbiAgICBjb25zdHJ1Y3Rvcihpbml0T3B0cyl7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB0eXBlb2YgaW5pdE9wdHMgPT09IFwic3RyaW5nXCIgPyB7XG4gICAgICAgICAgICBjb2RlOiBcIklOVEVSTkFMX1NFUlZFUl9FUlJPUlwiLFxuICAgICAgICAgICAgbWVzc2FnZTogaW5pdE9wdHNcbiAgICAgICAgfSA6IGluaXRPcHRzO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gb3B0cy5tZXNzYWdlID8/IG1lc3NhZ2VGcm9tVW5rbm93bihvcHRzLmNhdXNlLCBvcHRzLmNvZGUpO1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvZGUgPSBvcHRzLmNvZGU7XG4gICAgICAgIHRoaXMuZGF0YSA9IG9wdHMuZGF0YTtcbiAgICAgICAgaWYgKG9wdHMuY2F1c2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgdGhpcy5jYXVzZSA9IG9wdHMuY2F1c2U7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qob3B0cy5jYXVzZSkgJiYgdHlwZW9mIG9wdHMuY2F1c2Uuc3RhdHVzID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBvcHRzLmNhdXNlLnN0YXR1c1RleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMuY2F1c2UgPSBuZXcgRXJyb3IoYFJlc3BvbnNlICR7b3B0cy5jYXVzZS5zdGF0dXN9ICR7b3B0cy5jYXVzZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRzLmNhdXNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLmNhdXNlID0gbmV3IEVycm9yKG9wdHMuY2F1c2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jYXVzZSA9IG9wdHMuY2F1c2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHRvT2JqZWN0KGVycm9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiBlcnJvci5jb2RlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgIGRhdGE6IGVycm9yLmRhdGFcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIHNlcmlhbGl6ZShlcnJvcikge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoVXBsb2FkVGhpbmdFcnJvci50b09iamVjdChlcnJvcikpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEVycm9yVHlwZUZyb21TdGF0dXNDb2RlKHN0YXR1c0NvZGUpIHtcbiAgICBmb3IgKGNvbnN0IFtjb2RlLCBzdGF0dXNdIG9mIE9iamVjdC5lbnRyaWVzKEVSUk9SX0NPREVTKSl7XG4gICAgICAgIGlmIChzdGF0dXMgPT09IHN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2RlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcIklOVEVSTkFMX1NFUlZFUl9FUlJPUlwiO1xufVxuZnVuY3Rpb24gZ2V0U3RhdHVzQ29kZUZyb21FcnJvcihlcnJvcikge1xuICAgIHJldHVybiBFUlJPUl9DT0RFU1tlcnJvci5jb2RlXSA/PyA1MDA7XG59XG5jb25zdCBJTlRFUk5BTF9ET19OT1RfVVNFX19mYXRhbENsaWVudEVycm9yID0gKGUpPT5uZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgIGNvZGU6IFwiSU5URVJOQUxfQ0xJRU5UX0VSUk9SXCIsXG4gICAgICAgIG1lc3NhZ2U6IFwiU29tZXRoaW5nIHdlbnQgd3JvbmcuIFBsZWFzZSByZXBvcnQgdGhpcyB0byBVcGxvYWRUaGluZy5cIixcbiAgICAgICAgY2F1c2U6IGVcbiAgICB9KTtcblxuY2xhc3MgRmV0Y2hDb250ZXh0IGV4dGVuZHMgQ29udGV4dC5UYWcoXCJ1cGxvYWR0aGluZy9GZXRjaENvbnRleHRcIikoKSB7XG59XG4vLyBUZW1wb3JhcnkgRWZmZWN0IHdyYXBwZXJzIGJlbG93LlxuLy8gVE9ETyBzaG91bGQgYmUgcmVmYWN0b3JlZCB3aXRoIG11Y2ggbG92ZVxuLy8gVE9ETyBoYW5kbGUgZXJyb3IgcHJvcGVybHlcbmNvbnN0IGZldGNoRWZmID0gKGlucHV0LCBpbml0KT0+RWZmZWN0LmZsYXRNYXAoRmV0Y2hDb250ZXh0LCAoeyBmZXRjaCwgYmFzZUhlYWRlcnMgfSk9PntcbiAgICAgICAgY29uc3QgcmVxSW5mbyA9IHtcbiAgICAgICAgICAgIHVybDogaW5wdXQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIG1ldGhvZDogaW5pdD8ubWV0aG9kLFxuICAgICAgICAgICAgYm9keTogaW5pdD8uYm9keSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAuLi5maWx0ZXJPYmplY3RWYWx1ZXMoYmFzZUhlYWRlcnMsICh2KT0+diAhPSBudWxsKSxcbiAgICAgICAgICAgICAgICAuLi5pbml0Py5oZWFkZXJzXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBFZmZlY3QudHJ5UHJvbWlzZSh7XG4gICAgICAgICAgICB0cnk6ICgpPT5mZXRjaChpbnB1dCwge1xuICAgICAgICAgICAgICAgICAgICAuLi5pbml0LFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiByZXFJbmZvLmhlYWRlcnNcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGNhdGNoOiAoZXJyb3IpPT5uZXcgRmV0Y2hFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dDogcmVxSW5mb1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH0pLnBpcGUoRWZmZWN0Lm1hcCgocmVzKT0+T2JqZWN0LmFzc2lnbihyZXMsIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0VXJsOiByZXFJbmZvLnVybFxuICAgICAgICAgICAgfSkpLCBFZmZlY3Qud2l0aFNwYW4oXCJmZXRjaFwiLCB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgcmVxSW5mb1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgfSk7XG5jb25zdCBwYXJzZVJlc3BvbnNlSnNvbiA9IChyZXMpPT5FZmZlY3QudHJ5UHJvbWlzZSh7XG4gICAgICAgIHRyeTogYXN5bmMgKCk9PntcbiAgICAgICAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXMuanNvbigpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBqc29uLFxuICAgICAgICAgICAgICAgIG9rOiByZXMub2ssXG4gICAgICAgICAgICAgICAgc3RhdHVzOiByZXMuc3RhdHVzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBjYXRjaDogKGVycm9yKT0+bmV3IEludmFsaWRKc29uRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgIGlucHV0OiByZXMucmVxdWVzdFVybFxuICAgICAgICAgICAgfSlcbiAgICB9KS5waXBlKEVmZmVjdC5maWx0ZXJPckZhaWwoKHsgb2sgfSk9Pm9rLCAoeyBqc29uLCBzdGF0dXMgfSk9Pm5ldyBCYWRSZXF1ZXN0RXJyb3Ioe1xuICAgICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgICAgbWVzc2FnZTogYFJlcXVlc3QgdG8gJHtyZXMucmVxdWVzdFVybH0gZmFpbGVkIHdpdGggc3RhdHVzICR7c3RhdHVzfWAsXG4gICAgICAgICAgICBqc29uXG4gICAgICAgIH0pKSwgRWZmZWN0Lm1hcCgoeyBqc29uIH0pPT5qc29uKSwgRWZmZWN0LndpdGhTcGFuKFwicGFyc2VKc29uXCIpKTtcbmNvbnN0IHBhcnNlUmVxdWVzdEpzb24gPSAocmVxKT0+RWZmZWN0LnRyeVByb21pc2Uoe1xuICAgICAgICB0cnk6ICgpPT5yZXEuanNvbigpLFxuICAgICAgICBjYXRjaDogKGVycm9yKT0+bmV3IEludmFsaWRKc29uRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgIGlucHV0OiByZXEudXJsXG4gICAgICAgICAgICB9KVxuICAgIH0pLnBpcGUoRWZmZWN0LndpdGhTcGFuKFwicGFyc2VSZXF1ZXN0SnNvblwiKSk7XG4vKipcbiAqIFNjaGVkdWxlIHRoYXQgcmV0cmllcyB3aXRoIGV4cG9uZW50aWFsIGJhY2tvZmYsIHVwIHRvIDEgbWludXRlLlxuICogMTBtcyAqIDRebiwgd2hlcmUgbiBpcyB0aGUgbnVtYmVyIG9mIHJldHJpZXMuXG4gKi8gY29uc3QgZXhwb25lbnRpYWxCYWNrb2ZmID0gcGlwZShTY2hlZHVsZS5leHBvbmVudGlhbChEdXJhdGlvbi5taWxsaXMoMTApLCA0KSwgU2NoZWR1bGUuYW5kVGhlbkVpdGhlcihTY2hlZHVsZS5zcGFjZWQoRHVyYXRpb24uc2Vjb25kcygxKSkpLCBTY2hlZHVsZS5jb21wb3NlKFNjaGVkdWxlLmVsYXBzZWQpLCBTY2hlZHVsZS53aGlsZU91dHB1dChEdXJhdGlvbi5sZXNzVGhhbk9yRXF1YWxUbyhEdXJhdGlvbi5taW51dGVzKDEpKSkpO1xuXG5jb25zdCBnZW5lcmF0ZU1pbWVUeXBlcyA9IChmaWxlVHlwZXMpPT57XG4gICAgY29uc3QgYWNjZXB0ZWQgPSBmaWxlVHlwZXMubWFwKCh0eXBlKT0+e1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJibG9iXCIpIHJldHVybiBcImJsb2JcIjtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwicGRmXCIpIHJldHVybiBcImFwcGxpY2F0aW9uL3BkZlwiO1xuICAgICAgICBpZiAodHlwZS5pbmNsdWRlcyhcIi9cIikpIHJldHVybiB0eXBlO1xuICAgICAgICBlbHNlIHJldHVybiBgJHt0eXBlfS8qYDtcbiAgICB9KTtcbiAgICBpZiAoYWNjZXB0ZWQuaW5jbHVkZXMoXCJibG9iXCIpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY2VwdGVkO1xufTtcbmNvbnN0IGdlbmVyYXRlQ2xpZW50RHJvcHpvbmVBY2NlcHQgPSAoZmlsZVR5cGVzKT0+e1xuICAgIGNvbnN0IG1pbWVUeXBlcyA9IGdlbmVyYXRlTWltZVR5cGVzKGZpbGVUeXBlcyk7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhtaW1lVHlwZXMubWFwKCh0eXBlKT0+W1xuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIFtdXG4gICAgICAgIF0pKTtcbn07XG5mdW5jdGlvbiBnZXRGaWxlc0Zyb21DbGlwYm9hcmRFdmVudChldmVudCkge1xuICAgIGNvbnN0IGRhdGFUcmFuc2Zlckl0ZW1zID0gZXZlbnQuY2xpcGJvYXJkRGF0YT8uaXRlbXM7XG4gICAgaWYgKCFkYXRhVHJhbnNmZXJJdGVtcykgcmV0dXJuO1xuICAgIGNvbnN0IGZpbGVzID0gQXJyYXkuZnJvbShkYXRhVHJhbnNmZXJJdGVtcykucmVkdWNlKChhY2MsIGN1cnIpPT57XG4gICAgICAgIGNvbnN0IGYgPSBjdXJyLmdldEFzRmlsZSgpO1xuICAgICAgICByZXR1cm4gZiA/IFtcbiAgICAgICAgICAgIC4uLmFjYyxcbiAgICAgICAgICAgIGZcbiAgICAgICAgXSA6IGFjYztcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIGZpbGVzO1xufVxuLyoqXG4gKiBTaGFyZWQgaGVscGVycyBmb3Igb3VyIHByZW1hZGUgY29tcG9uZW50cyB0aGF0J3MgcmV1c2FibGUgYnkgbXVsdGlwbGUgZnJhbWV3b3Jrc1xuICovIGNvbnN0IGdlbmVyYXRlUGVybWl0dGVkRmlsZVR5cGVzID0gKGNvbmZpZyk9PntcbiAgICBjb25zdCBmaWxlVHlwZXMgPSBjb25maWcgPyBvYmplY3RLZXlzKGNvbmZpZykgOiBbXTtcbiAgICBjb25zdCBtYXhGaWxlQ291bnQgPSBjb25maWcgPyBPYmplY3QudmFsdWVzKGNvbmZpZykubWFwKCh2KT0+di5tYXhGaWxlQ291bnQpIDogW107XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmlsZVR5cGVzLFxuICAgICAgICBtdWx0aXBsZTogbWF4RmlsZUNvdW50LnNvbWUoKHYpPT52ICYmIHYgPiAxKVxuICAgIH07XG59O1xuY29uc3QgY2FwaXRhbGl6ZVN0YXJ0ID0gKHN0cik9PntcbiAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufTtcbmNvbnN0IElOVEVSTkFMX2RvRm9ybWF0dGluZyA9IChjb25maWcpPT57XG4gICAgaWYgKCFjb25maWcpIHJldHVybiBcIlwiO1xuICAgIGNvbnN0IGFsbG93ZWRUeXBlcyA9IG9iamVjdEtleXMoY29uZmlnKTtcbiAgICBjb25zdCBmb3JtYXR0ZWRUeXBlcyA9IGFsbG93ZWRUeXBlcy5tYXAoKGYpPT5mID09PSBcImJsb2JcIiA/IFwiZmlsZVwiIDogZik7XG4gICAgLy8gRm9ybWF0IG11bHRpLXR5cGUgdXBsb2FkZXIgbGFiZWwgYXMgXCJTdXBwb3J0cyB2aWRlb3MsIGltYWdlcyBhbmQgZmlsZXNcIjtcbiAgICBpZiAoZm9ybWF0dGVkVHlwZXMubGVuZ3RoID4gMSkge1xuICAgICAgICBjb25zdCBsYXN0VHlwZSA9IGZvcm1hdHRlZFR5cGVzLnBvcCgpO1xuICAgICAgICByZXR1cm4gYCR7Zm9ybWF0dGVkVHlwZXMuam9pbihcInMsIFwiKX0gYW5kICR7bGFzdFR5cGV9c2A7XG4gICAgfVxuICAgIC8vIFNpbmdsZSB0eXBlIHVwbG9hZGVyIGxhYmVsXG4gICAgY29uc3Qga2V5ID0gYWxsb3dlZFR5cGVzWzBdO1xuICAgIGNvbnN0IGZvcm1hdHRlZEtleSA9IGZvcm1hdHRlZFR5cGVzWzBdO1xuICAgIGNvbnN0IHsgbWF4RmlsZVNpemUsIG1heEZpbGVDb3VudCwgbWluRmlsZUNvdW50IH0gPSBjb25maWdba2V5XTtcbiAgICBpZiAobWF4RmlsZUNvdW50ICYmIG1heEZpbGVDb3VudCA+IDEpIHtcbiAgICAgICAgaWYgKG1pbkZpbGVDb3VudCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHttaW5GaWxlQ291bnR9IC0gJHttYXhGaWxlQ291bnR9ICR7Zm9ybWF0dGVkS2V5fXMgdXAgdG8gJHttYXhGaWxlU2l6ZX1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGAke2Zvcm1hdHRlZEtleX1zIHVwIHRvICR7bWF4RmlsZVNpemV9LCBtYXggJHttYXhGaWxlQ291bnR9YDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBgJHtmb3JtYXR0ZWRLZXl9ICgke21heEZpbGVTaXplfSlgO1xuICAgIH1cbn07XG5jb25zdCBhbGxvd2VkQ29udGVudFRleHRMYWJlbEdlbmVyYXRvciA9IChjb25maWcpPT57XG4gICAgcmV0dXJuIGNhcGl0YWxpemVTdGFydChJTlRFUk5BTF9kb0Zvcm1hdHRpbmcoY29uZmlnKSk7XG59O1xuY29uc3Qgc3R5bGVGaWVsZFRvQ2xhc3NOYW1lID0gKHN0eWxlRmllbGQsIGFyZ3MpPT57XG4gICAgaWYgKHR5cGVvZiBzdHlsZUZpZWxkID09PSBcInN0cmluZ1wiKSByZXR1cm4gc3R5bGVGaWVsZDtcbiAgICBpZiAodHlwZW9mIHN0eWxlRmllbGQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzdHlsZUZpZWxkKGFyZ3MpO1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIFwiXCI7XG59O1xuY29uc3Qgc3R5bGVGaWVsZFRvQ3NzT2JqZWN0ID0gKHN0eWxlRmllbGQsIGFyZ3MpPT57XG4gICAgaWYgKHR5cGVvZiBzdHlsZUZpZWxkID09PSBcIm9iamVjdFwiKSByZXR1cm4gc3R5bGVGaWVsZDtcbiAgICBpZiAodHlwZW9mIHN0eWxlRmllbGQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzdHlsZUZpZWxkKGFyZ3MpO1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJvYmplY3RcIikgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHt9O1xufTtcbmNvbnN0IGNvbnRlbnRGaWVsZFRvQ29udGVudCA9IChjb250ZW50RmllbGQsIGFyZyk9PntcbiAgICBpZiAoIWNvbnRlbnRGaWVsZCkgcmV0dXJuIG51bGw7XG4gICAgaWYgKHR5cGVvZiBjb250ZW50RmllbGQgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGNvbnRlbnRGaWVsZDtcbiAgICBpZiAodHlwZW9mIGNvbnRlbnRGaWVsZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbnRlbnRGaWVsZChhcmcpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn07XG5cbmNvbnN0IHNpZ25hdHVyZVByZWZpeCA9IFwiaG1hYy1zaGEyNTY9XCI7XG5jb25zdCBhbGdvcml0aG0gPSB7XG4gICAgbmFtZTogXCJITUFDXCIsXG4gICAgaGFzaDogXCJTSEEtMjU2XCJcbn07XG5jb25zdCBzaWduUGF5bG9hZCA9IGFzeW5jIChwYXlsb2FkLCBzZWNyZXQpPT57XG4gICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIGNvbnN0IHNpZ25pbmdLZXkgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmltcG9ydEtleShcInJhd1wiLCBlbmNvZGVyLmVuY29kZShzZWNyZXQpLCBhbGdvcml0aG0sIGZhbHNlLCBbXG4gICAgICAgIFwic2lnblwiXG4gICAgXSk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5zaWduKGFsZ29yaXRobSwgc2lnbmluZ0tleSwgZW5jb2Rlci5lbmNvZGUocGF5bG9hZCkpLnRoZW4oKHNpZyk9PkJ1ZmZlci5mcm9tKHNpZykudG9TdHJpbmcoXCJoZXhcIikpO1xuICAgIHJldHVybiBgJHtzaWduYXR1cmVQcmVmaXh9JHtzaWduYXR1cmV9YDtcbn07XG5jb25zdCB2ZXJpZnlTaWduYXR1cmUgPSBhc3luYyAocGF5bG9hZCwgc2lnbmF0dXJlLCBzZWNyZXQpPT57XG4gICAgY29uc3Qgc2lnID0gc2lnbmF0dXJlPy5zbGljZShzaWduYXR1cmVQcmVmaXgubGVuZ3RoKTtcbiAgICBpZiAoIXNpZykgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICBjb25zdCBzaWduaW5nS2V5ID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXCJyYXdcIiwgZW5jb2Rlci5lbmNvZGUoc2VjcmV0KSwgYWxnb3JpdGhtLCBmYWxzZSwgW1xuICAgICAgICBcInZlcmlmeVwiXG4gICAgXSk7XG4gICAgcmV0dXJuIGF3YWl0IGNyeXB0by5zdWJ0bGUudmVyaWZ5KGFsZ29yaXRobSwgc2lnbmluZ0tleSwgVWludDhBcnJheS5mcm9tKEJ1ZmZlci5mcm9tKHNpZywgXCJoZXhcIikpLCBlbmNvZGVyLmVuY29kZShwYXlsb2FkKSk7XG59O1xuXG5leHBvcnQgeyBBTExPV0VEX0ZJTEVfVFlQRVMsIEJhZFJlcXVlc3RFcnJvciwgRklMRVNJWkVfVU5JVFMsIEZldGNoQ29udGV4dCwgRmV0Y2hFcnJvciwgSU5URVJOQUxfRE9fTk9UX1VTRV9fZmF0YWxDbGllbnRFcnJvciwgSU5URVJOQUxfZG9Gb3JtYXR0aW5nLCBJbnZhbGlkRmlsZVNpemVFcnJvciwgSW52YWxpZEZpbGVUeXBlRXJyb3IsIEludmFsaWRKc29uRXJyb3IsIEludmFsaWRSb3V0ZUNvbmZpZ0Vycm9yLCBJbnZhbGlkVVJMRXJyb3IsIFJldHJ5RXJyb3IsIFVua25vd25GaWxlVHlwZUVycm9yLCBVcGxvYWRUaGluZ0Vycm9yLCBWYWxpZEFDTHMsIFZhbGlkQ29udGVudERpc3Bvc2l0aW9ucywgYWxsb3dlZENvbnRlbnRUZXh0TGFiZWxHZW5lcmF0b3IsIGFzQXJyYXksIGJ5dGVzVG9GaWxlU2l6ZSwgY2FwaXRhbGl6ZVN0YXJ0LCBjb250ZW50RGlzcG9zaXRpb24sIGNvbnRlbnRGaWVsZFRvQ29udGVudCwgZXhwb25lbnRpYWxCYWNrb2ZmLCBmZXRjaEVmZiwgZmlsZVNpemVUb0J5dGVzLCBmaWxsSW5wdXRSb3V0ZUNvbmZpZywgZmlsdGVyT2JqZWN0VmFsdWVzLCBnZW5lcmF0ZUNsaWVudERyb3B6b25lQWNjZXB0LCBnZW5lcmF0ZU1pbWVUeXBlcywgZ2VuZXJhdGVQZXJtaXR0ZWRGaWxlVHlwZXMsIGdlbmVyYXRlVXBsb2FkVGhpbmdVUkwsIGdldERlZmF1bHRTaXplRm9yVHlwZSwgZ2V0RXJyb3JUeXBlRnJvbVN0YXR1c0NvZGUsIGdldEZpbGVzRnJvbUNsaXBib2FyZEV2ZW50LCBnZXRGdWxsQXBpVXJsLCBnZXRSZXF1ZXN0VXJsLCBnZXRTdGF0dXNDb2RlRnJvbUVycm9yLCBnZXRUeXBlRnJvbUZpbGVOYW1lLCBpc09iamVjdCwgaXNSb3V0ZUFycmF5LCBvYmplY3RLZXlzLCBwYXJzZVJlcXVlc3RKc29uLCBwYXJzZVJlc3BvbnNlSnNvbiwgcmVzb2x2ZU1heWJlVXJsQXJnLCBzYWZlUGFyc2VKU09OLCBzZW12ZXJMaXRlLCBzaWduUGF5bG9hZCwgc3R5bGVGaWVsZFRvQ2xhc3NOYW1lLCBzdHlsZUZpZWxkVG9Dc3NPYmplY3QsIHZlcmlmeVNpZ25hdHVyZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@uploadthing+shared@6.7.4_@uploadthing+mime-types@0.2.10/node_modules/@uploadthing/shared/dist/index.js\n");

/***/ })

};
;